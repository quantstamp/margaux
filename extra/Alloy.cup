import java.util.Stack;
import java.util.List;
import java.util.ArrayList;
import java.util.TreeSet;
import java.util.Map;
import java.util.LinkedHashMap;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.Reader;
import java.io.IOException;
import java.io.StringReader;
import java_cup_11a.runtime.*;
import edu.mit.csail.sdg.alloy4.Err;
import edu.mit.csail.sdg.alloy4.ErrorFatal;
import edu.mit.csail.sdg.alloy4.ErrorSyntax;
import edu.mit.csail.sdg.alloy4.Pos;
import edu.mit.csail.sdg.alloy4.Pair;
import edu.mit.csail.sdg.alloy4.Util;
import edu.mit.csail.sdg.alloy4compiler.ast.Sig;
import edu.mit.csail.sdg.alloy4compiler.ast.EDecl;
import edu.mit.csail.sdg.alloy4compiler.ast.Expr;
import edu.mit.csail.sdg.alloy4compiler.ast.ExprAnd;
import edu.mit.csail.sdg.alloy4compiler.ast.ExprBinary;
import edu.mit.csail.sdg.alloy4compiler.ast.ExprBuiltin;
import edu.mit.csail.sdg.alloy4compiler.ast.ExprConstant;
import edu.mit.csail.sdg.alloy4compiler.ast.ExprUnary;
import edu.mit.csail.sdg.alloy4compiler.ast.ExprQuant;
import edu.mit.csail.sdg.alloy4compiler.ast.ExprVar;
import edu.mit.csail.sdg.alloy4compiler.ast.ExprCallOrJoin;
import edu.mit.csail.sdg.alloy4compiler.ast.ExprLet;
import edu.mit.csail.sdg.alloy4compiler.ast.ExprQuantt;

//===========================================================================//

parser code {:

  public CompModule alloymodule=null;
  public String alloyfile="";

  @SuppressWarnings("unchecked")
  @Override public Symbol parse() throws java.lang.Exception {
     int act; // current action code
     Symbol lhs_sym = null; // the Symbol/stack element returned by a reduce
     short handle_size, lhs_sym_num; // information about production being reduced with
     production_tab = production_table();
     action_tab     = action_table();
     reduce_tab     = reduce_table();
     init_actions();
     user_init();
     // start
     cur_token = scan();
     stack.removeAllElements();
     stack.push(getSymbolFactory().startSymbol("START", 0, start_state()));
     tos = 0;
     for (_done_parsing = false; !_done_parsing; ) {
        act = get_action(((Symbol)stack.peek()).parse_state, cur_token.sym);
        if (act > 0) { // "shift"; thus, we shift to the encoded state by pushing it on the stack
           cur_token.parse_state = act-1;
           stack.push(cur_token);
           tos++;
           cur_token = scan();
        } else if (act<0) { // "reduce"
           lhs_sym = do_action((-act)-1, this, stack, tos);
           lhs_sym_num = production_tab[(-act)-1][0];
           handle_size = production_tab[(-act)-1][1];
           for (int i = 0; i < handle_size; i++)  {  stack.pop(); tos--; }
           act = get_reduce(((Symbol)stack.peek()).parse_state, lhs_sym_num);
           lhs_sym.parse_state = act;
           stack.push(lhs_sym);
           tos++;
        } else { // "error"
           syntax_error(cur_token);
           done_parsing();
        }
     }
     return lhs_sym;
  }

  private Pos alloypos(Symbol x) {
    if (x==null) return null;
    if (x.value instanceof Pos) return (Pos)(x.value);
    if (x.value instanceof Expr) return ((Expr)(x.value)).pos;
    return x.pos;
  }

  public void syntax_error(Symbol x) throws Err {
    Map<Integer,String> ch=new LinkedHashMap<Integer,String>();
    ch.put(CompSym.ABSTRACT        , "abstract");
    ch.put(CompSym.ALL             , "all");
    ch.put(CompSym.ALL2            , "all");
    ch.put(CompSym.ANY_ARROW_LONE  , "set");
    ch.put(CompSym.ANY_ARROW_ONE   , "set");
    ch.put(CompSym.ANY_ARROW_SOME  , "set");
    ch.put(CompSym.AS              , "as");
    ch.put(CompSym.ASSERT          , "assert");
    ch.put(CompSym.BUT             , "but");
    ch.put(CompSym.CHECK           , "check");
    ch.put(CompSym.ELSE            , "else");
    ch.put(CompSym.EXACTLY         , "exactly");
    ch.put(CompSym.EXPECT          , "expect");
    ch.put(CompSym.EXTENDS         , "extends");
    ch.put(CompSym.FACT            , "fact");
    ch.put(CompSym.FOR             , "for");
    ch.put(CompSym.FUN             , "fun");
    ch.put(CompSym.ID              , "NAME");
    ch.put(CompSym.IDEN            , "iden");
    ch.put(CompSym.IN              , "in");
    ch.put(CompSym.INT             , "int");
    ch.put(CompSym.LET             , "let");
    ch.put(CompSym.LONE            , "lone");
    ch.put(CompSym.LONE2           , "lone");
    ch.put(CompSym.LONE_ARROW_ANY  , "lone");
    ch.put(CompSym.LONE_ARROW_LONE , "lone");
    ch.put(CompSym.LONE_ARROW_ONE  , "lone");
    ch.put(CompSym.LONE_ARROW_SOME , "lone");
    ch.put(CompSym.MODULE          , "module");
    ch.put(CompSym.NO              , "no");
    ch.put(CompSym.NO2             , "no");
    ch.put(CompSym.NONE            , "none");
    ch.put(CompSym.NUMBER          , "NUMBER");
    ch.put(CompSym.ONE             , "one");
    ch.put(CompSym.ONE2            , "one");
    ch.put(CompSym.ONE_ARROW_ANY   , "one");
    ch.put(CompSym.ONE_ARROW_LONE  , "one");
    ch.put(CompSym.ONE_ARROW_ONE   , "one");
    ch.put(CompSym.ONE_ARROW_SOME  , "one");
    ch.put(CompSym.OPEN            , "open");
    ch.put(CompSym.PRED            , "pred");
    ch.put(CompSym.RUN             , "run");
    ch.put(CompSym.SET             , "set");
    ch.put(CompSym.SIG             , "sig");
    ch.put(CompSym.SIGINT          , "Int");
    ch.put(CompSym.SOME            , "some");
    ch.put(CompSym.SOME2           , "some");
    ch.put(CompSym.SOME_ARROW_ANY  , "some");
    ch.put(CompSym.SOME_ARROW_LONE , "some");
    ch.put(CompSym.SOME_ARROW_ONE  , "some");
    ch.put(CompSym.SOME_ARROW_SOME , "some");
    ch.put(CompSym.SUM             , "sum");
    ch.put(CompSym.SUM2            , "sum");
    ch.put(CompSym.THIS            , "this");
    ch.put(CompSym.UNIV            , "univ");
    ch.put(CompSym.AMPERSAND       , "&");
    ch.put(CompSym.AND             , "&&");
    ch.put(CompSym.ARROW           , "->");
    ch.put(CompSym.AT              , "@");
    ch.put(CompSym.BAR             , "|");
    ch.put(CompSym.CARET           , "^");
    ch.put(CompSym.COLON           , ":");
    ch.put(CompSym.COMMA           , ",");
    ch.put(CompSym.DOMAIN          , "<:");
    ch.put(CompSym.DOT             , ".");
    ch.put(CompSym.EQUALS          , "=");
    ch.put(CompSym.GT              , ">");
    ch.put(CompSym.GTE             , ">=");
    ch.put(CompSym.HASH            , "#");
    ch.put(CompSym.IFF             , "<=>");
    ch.put(CompSym.IMPLIES         , "->");
    ch.put(CompSym.LBRACE          , "{");
    ch.put(CompSym.LBRACKET        , "[");
    ch.put(CompSym.LPAREN          , "(");
    ch.put(CompSym.LT              , "<");
    ch.put(CompSym.LTE             , "=<");
    ch.put(CompSym.MINUS           , "-");
    ch.put(CompSym.NOT             , "!");
    ch.put(CompSym.NOTEQUALS       , "!");
    ch.put(CompSym.NOTGT           , "!");
    ch.put(CompSym.NOTGTE          , "!");
    ch.put(CompSym.NOTIN           , "!");
    ch.put(CompSym.NOTLT           , "!");
    ch.put(CompSym.NOTLTE          , "!");
    ch.put(CompSym.OR              , "||");
    ch.put(CompSym.PLUS            , "+");
    ch.put(CompSym.PLUSPLUS        , "++");
    ch.put(CompSym.RANGE           , ":>");
    ch.put(CompSym.RBRACE          , "}");
    ch.put(CompSym.RBRACKET        , "]");
    ch.put(CompSym.RPAREN          , ")");
    ch.put(CompSym.SLASH           , "/");
    ch.put(CompSym.STAR            , "*");
    ch.put(CompSym.TILDE           , "~");
    TreeSet<String> list=new TreeSet<String>();
    Pos p=alloypos(x);
    if (!stack.empty()) for(Map.Entry<Integer,String> e:ch.entrySet()) {
        int key=e.getKey(), act=get_action(((Symbol)stack.peek()).parse_state, key);
        if (act==0) continue;
        try {
            if (act>0 || alloy_confirm(key)) list.add(e.getValue());
        } catch(Throwable ex) {
            // If the parser is really really confused, alloy_confirm() could fail with array out-of-bound exception, etc.
        }
    }
    String result="There are "+list.size()+" possible tokens that can appear here:\n";
    for(String item:list) result=result+item+" ";
    throw new ErrorSyntax(p, (list.size()!=0)?result:"");
  }

  private boolean alloy_confirm(int key) {
    int state = ((Symbol)stack.peek()).parse_state;
    Stack<Object> newstack=new Stack<Object>(); for(Object x:stack) newstack.push(x);
    while(true) {
      int act = get_action(state, key);
      if (act>0) return true;
      if (act==0) return false;
      int lhs_sym_num = production_tab[(-act)-1][0];
      int handle_size = production_tab[(-act)-1][1];
      for (int i = 0; i < handle_size; i++) { if (newstack.empty()) return false; newstack.pop(); }
      if (newstack.empty()) return false;
      if (newstack.peek() instanceof Symbol) state=((Symbol)newstack.peek()).parse_state;
      state=get_reduce(state, lhs_sym_num);
      newstack.push(null);
    }
  }

  static CompModule alloy_parseStream(Map<String,String> fc, World world, int lineOffset, final String filename, final String prefix)
  throws Err, FileNotFoundException, IOException {
    Reader isr=null;
    try {
        if (world==null) world=new World();
        String content=fc.get(filename);
        if (content==null) { content=Util.readAll(filename); fc.put(filename,content); }
        isr=new StringReader(content);
        CompModule u=new CompModule(world,prefix);
        CompFilter s=new CompFilter(world,filename,lineOffset,new BufferedReader(isr));
        CompParser p=new CompParser(s);
        p.alloymodule=u;
        p.alloyfile=filename;
        try {p.parse();} catch(Throwable ex) {if (ex instanceof Err) throw (Err)ex; throw new ErrorFatal("Parser Exception: "+ex);}
        return u;
    } finally {
        Util.close(isr);
    }
  }

:};

action code {:
    /**
     * This function is needed to handle a difficult parsing ambiguity.
     *
     * <p>
     * "some EXPR", "one EXPR", and "lone EXPR"
     * can be either formulas (saying the EXPR has at least 1, exactly 1, or at most 1 tuple),
     * or multiplicity constraints (saying something else has this multiplicity).
     *
     * <p>
     * So we let the parser generate the former by default.
     * And whenever we construct a EDecl(x,y) object,
     * or an ExprBinary.Op.IN(x,y) object, or a function return type,
     * we call this method on y to convert it into a multiplicity constraint.
     *
     * <p>
     * This is safe, because in all 3 cases, a formula would be illegal.
     * So the first form is always wrong.
     *
     * <p>
     * And this is sufficient, because those are the only 3 places
     * where a mulitplicity constraint is allowed to appear.
     *
     * @return a newly formed multiplciity constraint (if this.op==SOME or LONE or ONE),
     * otherwise it just returns the original node.
     */
    private Expr mult(Expr x) throws Err {
        if (x instanceof ExprUnary) {
           ExprUnary y=(ExprUnary)x;
           if (y.op==ExprUnary.Op.SOME) return ExprUnary.Op.SOMEOF.make(y.pos, y.sub);
           if (y.op==ExprUnary.Op.LONE) return ExprUnary.Op.LONEOF.make(y.pos, y.sub);
           if (y.op==ExprUnary.Op.ONE) return ExprUnary.Op.ONEOF.make(y.pos, y.sub);
        }
        return x;
    }
    private Expr alloyTrue(Pos pos) throws Err { return ExprConstant.Op.TRUE.make(pos,0); }

    private Expr t(Expr x) throws Err {
      if (!(x instanceof ExprCallOrJoin)) return x;
      ExprCallOrJoin j=(ExprCallOrJoin)x;
      if (j.right instanceof ExprVar) {
         String n=((ExprVar)(j.right)).label;
         if (n.equals("int"))  return ExprUnary.Op.CAST2INT.make(x.pos, j.left);
         if (n.equals("disj")) return ExprBuiltin.makeDISJOINT(x.pos, Util.asList(j.left));
      }
      if (j.right instanceof ExprBuiltin && ((ExprBuiltin)(j.right)).op==ExprBuiltin.Op.DISJOINT) {
         ExprBuiltin n=((ExprBuiltin)(j.right));
         List<Expr> args=new ArrayList<Expr>(n.args);
         args.add(j.left);
         return ExprBuiltin.makeDISJOINT(x.pos, args);
      }
      return x;
    }
:};

//===========================================================================//

terminal Pos ARROW;            //  ->
terminal Pos ANY_ARROW_SOME;   //  ->some    // The filter allows whitespace/comment in these 15 "*->*" tokens
terminal Pos ANY_ARROW_ONE;    //  ->one
terminal Pos ANY_ARROW_LONE;   //  ->lone
terminal Pos SOME_ARROW_ANY;   //  some->
terminal Pos SOME_ARROW_SOME;  //  some->some
terminal Pos SOME_ARROW_ONE;   //  some->one
terminal Pos SOME_ARROW_LONE;  //  some->lone
terminal Pos ONE_ARROW_ANY;    //  one->
terminal Pos ONE_ARROW_SOME;   //  one->some
terminal Pos ONE_ARROW_ONE;    //  one->one
terminal Pos ONE_ARROW_LONE;   //  one->lone
terminal Pos LONE_ARROW_ANY;   //  lone->any
terminal Pos LONE_ARROW_SOME;  //  lone->some
terminal Pos LONE_ARROW_ONE;   //  lone->one
terminal Pos LONE_ARROW_LONE;  //  lone->lone

terminal Pos ABSTRACT;         //  abstract
terminal Pos ALL;              //  all      // The filter enables us to disambiguate
terminal Pos ALL2;             //  all      // The filter enables us to disambiguate
terminal Pos AMPERSAND;        //  &
terminal Pos AND;              //  && and
terminal Pos AS;               //  as
terminal Pos ASSERT;           //  assert
terminal Pos AT;               //  @
terminal Pos BAR;              //  |
terminal Pos BUT;              //  but
terminal Pos CARET;            //  ^
terminal Pos CHECK;            //  check
terminal Pos COLON;            //  :
terminal Pos COMMA;            //  ,
terminal Pos DISJ;             //  disj disjoint
terminal Pos DOMAIN;           //  <:
terminal Pos DOT;              //  .
terminal Pos ELSE;             //  else
terminal Pos EQUALS;           //  =  ==
terminal Pos EXACTLY;          //  exactly
terminal Pos EXH;              //  exh exhaustive
terminal Pos EXPECT;           //  expect
terminal Pos EXTENDS;          //  extends
terminal Pos FACT;             //  fact
terminal Pos FOR;              //  for
terminal Pos FUN;              //  fun
terminal Pos GT;               //  >
terminal Pos GTE;              //  >=
terminal Pos HASH;             //  #
terminal Pos IDEN;             //  iden
terminal Pos IFF;              //  <=> iff
terminal Pos IMPLIES;          //  => implies
terminal Pos IN;               //  in
terminal Pos INT;              //  int
terminal Pos LBRACE;           //  {
terminal Pos LBRACKET;         //  [
terminal Pos LET;              //  let
terminal Pos LONE2;            //  lone      // The filter enables us to disambiguate
terminal Pos LONE;             //  lone      // The filter enables us to disambiguate
terminal Pos LPAREN;           //  (
terminal Pos LT;               //  <
terminal Pos LTE;              //  =<
terminal Pos MINUS;            //  -
terminal Pos MODULE;           //  module
terminal Pos NO2;              //  no        // The filter enables us to disambiguate
terminal Pos NO;               //  no        // The filter enables us to disambiguate
terminal Pos NONE;             //  none
terminal Pos NOT;              //  !      not
terminal Pos NOTEQUALS;        //  !=     not=    // The filter allows whitespace/comment in between
terminal Pos NOTGT;            //  !>     not>    // The filter allows whitespace/comment in between
terminal Pos NOTGTE;           //  !>=    not>=   // The filter allows whitespace/comment in between
terminal Pos NOTIN;            //  !in    notin   // The filter allows whitespace/comment in between
terminal Pos NOTLT;            //  !<     not<    // The filter allows whitespace/comment in between
terminal Pos NOTLTE;           //  !=<    not=<   // The filter allows whitespace/comment in between
terminal Pos ONE2;             //  one            // The filter enables us to disambiguate
terminal Pos ONE;              //  one            // The filter enables us to disambiguate
terminal Pos OPEN;             //  open
terminal Pos OR;               //  ||     or
terminal Pos PART;             //  part   partition
terminal Pos PLUS;             //  +
terminal Pos PLUSPLUS;         //  ++
terminal Pos PRED;             //  pred
terminal Pos RANGE;            //  :>
terminal Pos RBRACE;           //  }
terminal Pos RBRACKET;         //  ]
terminal Pos RPAREN;           //  )
terminal Pos RUN;              //  run
terminal Pos SEQ;              //  seq
terminal Pos SET;              //  set
terminal Pos SIG;              //  sig
terminal Pos SIGINT;           //  Int
terminal Pos SLASH;            //  /
terminal Pos SOME2;            //  some      // The filter enables us to disambiguate
terminal Pos SOME;             //  some      // The filter enables us to disambiguate
terminal Pos STAR;             //  *
terminal Pos SUM2;             //  sum       // The filter enables us to disambiguate
terminal Pos SUM;              //  sum       // The filter enables us to disambiguate
terminal Pos THIS;             //  this
terminal Pos TILDE;            //  ~
terminal Pos UNIV;             //  univ

terminal ExprVar ID;

terminal Expr NUMBER;

//===========================================================================//

nonterminal Expr                       AndExpr;
nonterminal Expr                       BaseExpr;
nonterminal Expr                       BracketExpr;
nonterminal Expr                       CompareExpr;
nonterminal String                     CmdLabel;
nonterminal List<ExprVar>                CmdOpt;
nonterminal EDecl                      Decla;
nonterminal List<EDecl>                Declp;
nonterminal List<EDecl>                Decls;
nonterminal Expr                       DomainExpr;
nonterminal Expr                       DotExpr;
nonterminal Expr                       EquivExpr;
nonterminal String                     Expects;
nonterminal Expr                       Expr;
nonterminal Expr                       Super;
nonterminal Expr                       SuperOpt;
nonterminal Expr                       SuperP;
nonterminal Expr                       SuperOrBar;
nonterminal List<Expr>                 Exprs;
nonterminal List<Expr>                 Exprp;
nonterminal Expr                       First;
nonterminal                            Function;
nonterminal List<ExprVar>                Hint;
nonterminal Expr                       ImpliesExpr;
nonterminal Expr                       ImpliesExprClose;
nonterminal Expr                       ImpliesExprOpen;
nonterminal Expr                       IntersectExpr;
nonterminal Expr                       Let;
nonterminal                            Module;
nonterminal ExprVar                      Name;
nonterminal ExprVar                      NameHelper;
nonterminal List<ExprVar>                Names;
nonterminal Expr                       NegExpr;
nonterminal Expr                       NumUnopExpr;
nonterminal                            Open;
nonterminal                            Opens;
nonterminal Expr                       OrExpr;
nonterminal Expr                       OverrideExpr;
nonterminal                            Paragraphs;
nonterminal                            Predicate;
nonterminal Expr                       RangeExpr;
nonterminal Expr                       RelationExpr;
nonterminal List<String>               Scope;
nonterminal                            Sig;
nonterminal Pair<Pos,List<String>>     SigIn;
nonterminal List<Pos>                  SigQual;
nonterminal List<Pos>                  SigQuals;
nonterminal ExprVar                      SigRef;
nonterminal List<ExprVar>                SigRefp;
nonterminal List<ExprVar>                SigRefs;
nonterminal Pair<Pos,List<String>>     SigRefu;
nonterminal                            Specification;
nonterminal List<String>               Typescopes;
nonterminal List<String>               Typescope;
nonterminal Expr                       UnionDiffExpr;
nonterminal Expr                       UnopExpr;

//===========================================================================//

Specification ::= Module Opens Paragraphs ;

Module ::= MODULE:o Name:n                           {: parser.alloymodule.makeModule(o                            , n.label , new ArrayList<ExprVar>()); :};
Module ::= MODULE:o Name:n LBRACKET Names:b RBRACKET {: parser.alloymodule.makeModule(o                            , n.label , b                     );   :};
Module ::=                                           {: parser.alloymodule.makeModule(new Pos(parser.alloyfile,1,1), ""     , new ArrayList<ExprVar>());  :};

Open ::= OPEN:o Name:a                                         {: parser.alloymodule.addOpen(o.merge(a.pos), a.label, new ArrayList<ExprVar>(), "");      :};
Open ::= OPEN:o Name:a                               AS Name:c {: parser.alloymodule.addOpen(o.merge(c.pos), a.label, new ArrayList<ExprVar>(), c.label); :};
Open ::= OPEN:o Name:a LBRACKET SigRefs:b RBRACKET:c           {: parser.alloymodule.addOpen(o.merge(c),     a.label, b, "");                             :};
Open ::= OPEN:o Name:a LBRACKET SigRefs:b RBRACKET   AS Name:c {: parser.alloymodule.addOpen(o.merge(c.pos), a.label, b, c.label);                        :};

Opens ::=            ;
Opens ::= Opens Open ;

Paragraphs ::= Paragraphs FACT:o          Super:e {: parser.alloymodule.addFact      (o,""     ,e); :};
Paragraphs ::= Paragraphs FACT:o   Name:n Super:e {: parser.alloymodule.addFact      (o,n.label,e); :};
Paragraphs ::= Paragraphs ASSERT:o        Super:e {: parser.alloymodule.addAssertion (o,""     ,e); :};
Paragraphs ::= Paragraphs ASSERT:o Name:n Super:e {: parser.alloymodule.addAssertion (o,n.label,e); :};
Paragraphs ::= Paragraphs Sig             ;
Paragraphs ::= Paragraphs FUN Function    ;
Paragraphs ::= Paragraphs PRED Predicate  ;
Paragraphs ::=                            ;

CmdLabel ::=           {: RESULT="";      :};
CmdLabel ::= DOT ID:i  {: RESULT=i.label; :};

CmdOpt ::=                               {: RESULT=new ArrayList<ExprVar>(); :};
CmdOpt ::= LBRACKET SigRefp:o RBRACKET   {: RESULT=o;                      :};

Paragraphs ::= Paragraphs CHECK:o CmdLabel:x CmdOpt:y Super:e  Scope:s  {:
  int bitwidth = -1 , maxseq = -1;
  int overall = s.get(0).length()>0 ? Integer.parseInt(s.get(0)) : -1;
  int expects = s.get(1).length()>0 ? Integer.parseInt(s.get(1)) : -1;
  Map<String,Integer> scope=new LinkedHashMap<String,Integer>();
  for(int i=2; i<s.size()-1; i=i+2) {
    int j;
    String a=s.get(i);
    String b=s.get(i+1);
    if (a.charAt(0)=='e') { j=Integer.parseInt(a.substring(1)); j=(0-j)-1; } else { j=Integer.parseInt(a); }
    if (scope.containsKey(b)) throw new ErrorSyntax(o,"The scope of the sig \""+b+"\" cannot be specified more than once.");
    scope.put(b,j);
  }
  if (scope.containsKey("int")) bitwidth=scope.remove("int");
  if (scope.containsKey("seq")) maxseq=scope.remove("seq");
  parser.alloymodule.addCommand(o, e, true, overall, bitwidth, maxseq, expects, scope, x, y);
:};

Paragraphs ::= Paragraphs CHECK:o CmdLabel:x CmdOpt:y Name:n  Scope:s  {:
  int bitwidth = -1 , maxseq = -1;
  int overall = s.get(0).length()>0 ? Integer.parseInt(s.get(0)) : -1;
  int expects = s.get(1).length()>0 ? Integer.parseInt(s.get(1)) : -1;
  Map<String,Integer> scope=new LinkedHashMap<String,Integer>();
  for(int i=2; i<s.size()-1; i=i+2) {
    int j;
    String a=s.get(i);
    String b=s.get(i+1);
    if (a.charAt(0)=='e') { j=Integer.parseInt(a.substring(1)); j=(0-j)-1; } else { j=Integer.parseInt(a); }
    if (scope.containsKey(b)) throw new ErrorSyntax(o,"The scope of the sig \""+b+"\" cannot be specified more than once.");
    scope.put(b,j);
  }
  if (scope.containsKey("int")) bitwidth=scope.remove("int");
  if (scope.containsKey("seq")) maxseq=scope.remove("seq");
  parser.alloymodule.addCommand(o, n.label, true, overall, bitwidth, maxseq, expects, scope, x, y);
:};

Paragraphs ::= Paragraphs RUN:o CmdLabel:x CmdOpt:y Name:n  Scope:s  {:
  int bitwidth = -1 , maxseq = -1;
  int overall = s.get(0).length()>0 ? Integer.parseInt(s.get(0)) : -1;
  int expects = s.get(1).length()>0 ? Integer.parseInt(s.get(1)) : -1;
  Map<String,Integer> scope=new LinkedHashMap<String,Integer>();
  for(int i=2; i<s.size()-1; i=i+2) {
    int j;
    String a=s.get(i);
    String b=s.get(i+1);
    if (a.charAt(0)=='e') { j=Integer.parseInt(a.substring(1)); j=(0-j)-1; } else { j=Integer.parseInt(a); }
    if (scope.containsKey(b)) throw new ErrorSyntax(o,"The scope of the sig \""+b+"\" cannot be specified more than once.");
    scope.put(b,j);
  }
  if (scope.containsKey("int")) bitwidth=scope.remove("int");
  if (scope.containsKey("seq")) maxseq=scope.remove("seq");
  parser.alloymodule.addCommand(o, n.label, false, overall, bitwidth, maxseq, expects, scope, x, y);
:};

Paragraphs ::= Paragraphs RUN:o CmdLabel:x CmdOpt:y Super:e  Scope:s  {:
  int bitwidth = -1 , maxseq = -1;
  int overall = s.get(0).length()>0 ? Integer.parseInt(s.get(0)) : -1;
  int expects = s.get(1).length()>0 ? Integer.parseInt(s.get(1)) : -1;
  Map<String,Integer> scope=new LinkedHashMap<String,Integer>();
  for(int i=2; i<s.size()-1; i=i+2) {
    int j;
    String a=s.get(i);
    String b=s.get(i+1);
    if (a.charAt(0)=='e') { j=Integer.parseInt(a.substring(1)); j=(0-j)-1; } else { j=Integer.parseInt(a); }
    if (scope.containsKey(b)) throw new ErrorSyntax(o,"The scope of the sig \""+b+"\" cannot be specified more than once.");
    scope.put(b,j);
  }
  if (scope.containsKey("int")) bitwidth=scope.remove("int");
  if (scope.containsKey("seq")) maxseq=scope.remove("seq");
  parser.alloymodule.addCommand(o, e, false, overall, bitwidth, maxseq, expects, scope, x, y);
:};

Expects    ::=                 {: RESULT="";                         :};
Expects    ::= EXPECT NUMBER:a {: RESULT=""+((ExprConstant)a).num(); :};

Scope      ::= FOR NUMBER:a                  Expects:c {: RESULT=new ArrayList<String>(); RESULT.add(""+((ExprConstant)a).num()); RESULT.add(c);                   :};
Scope      ::= FOR NUMBER:a BUT Typescopes:b Expects:c {: RESULT=new ArrayList<String>(); RESULT.add(""+((ExprConstant)a).num()); RESULT.add(c); RESULT.addAll(b); :};
Scope      ::= FOR              Typescopes:b Expects:c {: RESULT=new ArrayList<String>(); RESULT.add("");                         RESULT.add(c); RESULT.addAll(b); :};
Scope      ::=                               Expects:c {: RESULT=new ArrayList<String>(); RESULT.add("");                         RESULT.add(c);                   :};

Typescopes ::= Typescope:a                    {: RESULT=a;               :};
Typescopes ::= Typescopes:a COMMA Typescope:b {: RESULT=a; a.addAll(b);  :};

Typescope  ::= EXACTLY NUMBER:a Name:b        {: RESULT=new ArrayList<String>(); RESULT.add("e"+((ExprConstant)a).num()); RESULT.add(b.label); :};
Typescope  ::=         NUMBER:a Name:b        {: RESULT=new ArrayList<String>(); RESULT.add( ""+((ExprConstant)a).num()); RESULT.add(b.label); :};
Typescope  ::= EXACTLY NUMBER:a INT           {: RESULT=new ArrayList<String>(); RESULT.add("e"+((ExprConstant)a).num()); RESULT.add("int");   :};
Typescope  ::=         NUMBER:a INT           {: RESULT=new ArrayList<String>(); RESULT.add( ""+((ExprConstant)a).num()); RESULT.add("int");   :};
Typescope  ::= EXACTLY NUMBER:a SEQ           {: RESULT=new ArrayList<String>(); RESULT.add("e"+((ExprConstant)a).num()); RESULT.add("seq");   :};
Typescope  ::=         NUMBER:a SEQ           {: RESULT=new ArrayList<String>(); RESULT.add( ""+((ExprConstant)a).num()); RESULT.add("seq");   :};
Typescope  ::= EXACTLY NUMBER:a UNIV          {: if (1==1) throw new ErrorSyntax(a.pos, "You cannot set a scope on univ."); :};
Typescope  ::=         NUMBER:a UNIV          {: if (1==1) throw new ErrorSyntax(a.pos, "You cannot set a scope on univ."); :};
Typescope  ::= EXACTLY NUMBER:a SIGINT        {: if (1==1) throw new ErrorSyntax(a.pos, "You can no longer set a scope on Int; the number of Int atoms is always exactly equal to 2^(integer bitwidth).\n"); :};
Typescope  ::=         NUMBER:a SIGINT        {: if (1==1) throw new ErrorSyntax(a.pos, "You can no longer set a scope on Int; the number of Int atoms is always exactly equal to 2^(integer bitwidth).\n"); :};
Typescope  ::= EXACTLY NUMBER:a NONE          {: if (1==1) throw new ErrorSyntax(a.pos, "You cannot set a scope on none."); :};
Typescope  ::=         NUMBER:a NONE          {: if (1==1) throw new ErrorSyntax(a.pos, "You cannot set a scope on none."); :};

First ::= Name:x   {: RESULT=x;                                     :};
First ::= UNIV:x   {: RESULT=ExprUnary.Op.NOOP.make(x, Sig.UNIV);   :};
First ::= SIGINT:x {: RESULT=ExprUnary.Op.NOOP.make(x, Sig.SIGINT); :};
First ::= NONE:x   {: RESULT=ExprUnary.Op.NOOP.make(x, Sig.NONE);   :};

Function ::=             Name:n LPAREN   Decls:d RPAREN   COLON Expr:r Super:v {: parser.alloymodule.addFunc(n.pos,n.label,null,d                     ,mult(r),v); :};
Function ::=             Name:n LBRACKET Decls:d RBRACKET COLON Expr:r Super:v {: parser.alloymodule.addFunc(n.pos,n.label,null,d                     ,mult(r),v); :};
Function ::=             Name:n                           COLON Expr:r Super:v {: parser.alloymodule.addFunc(n.pos,n.label,null,new ArrayList<EDecl>(),mult(r),v); :};
Function ::= First:f DOT Name:n LPAREN   Decls:d RPAREN   COLON Expr:r Super:v {: parser.alloymodule.addFunc(n.pos,n.label,f   ,d                     ,mult(r),v); :};
Function ::= First:f DOT Name:n LBRACKET Decls:d RBRACKET COLON Expr:r Super:v {: parser.alloymodule.addFunc(n.pos,n.label,f   ,d                     ,mult(r),v); :};
Function ::= First:f DOT Name:n                           COLON Expr:r Super:v {: parser.alloymodule.addFunc(n.pos,n.label,f   ,new ArrayList<EDecl>(),mult(r),v); :};

Predicate ::=             Name:n LPAREN   Decls:d RPAREN   Super:v   {: parser.alloymodule.addFunc(n.pos,n.label,null,d                     ,null,v); :};
Predicate ::=             Name:n LBRACKET Decls:d RBRACKET Super:v   {: parser.alloymodule.addFunc(n.pos,n.label,null,d                     ,null,v); :};
Predicate ::=             Name:n                           Super:v   {: parser.alloymodule.addFunc(n.pos,n.label,null,new ArrayList<EDecl>(),null,v); :};
Predicate ::= First:f DOT Name:n LPAREN   Decls:d RPAREN   Super:v   {: parser.alloymodule.addFunc(n.pos,n.label,f   ,d                     ,null,v); :};
Predicate ::= First:f DOT Name:n LBRACKET Decls:d RBRACKET Super:v   {: parser.alloymodule.addFunc(n.pos,n.label,f   ,d                     ,null,v); :};
Predicate ::= First:f DOT Name:n                           Super:v   {: parser.alloymodule.addFunc(n.pos,n.label,f   ,new ArrayList<EDecl>(),null,v); :};

Hint ::=             {: RESULT=null;           :};
Hint ::= HASH Name:e {: RESULT=Util.asList(e); :};

Sig ::= Hint:h SigQuals:a SIG Names:b SigIn:c LBRACE Decls:d RBRACE SuperOpt:e
 {:
   CompModule.SigAST s;
   for(ExprVar bbb:b) {
     String bb=bbb.label;
     if (c==null)
       s=parser.alloymodule.addSig(h, bbb.pos, bb, a.get(0)!=null, a.get(1)!=null, a.get(2)!=null, a.get(3)!=null, null,null,d,e);
     else if (c.b.get(0)==null) {
       s=parser.alloymodule.addSig(h, bbb.pos, bb, a.get(0)!=null, a.get(1)!=null, a.get(2)!=null, a.get(3)!=null, null,(String)(c.b.get(1)),d,e);
       s.extendsPosition=c.a;
       }
     else {
       s=parser.alloymodule.addSig(h, bbb.pos, bb, a.get(0)!=null, a.get(1)!=null, a.get(2)!=null, a.get(3)!=null, c.b, null, d, e);
       s.inPosition=c.a;
       }
     s.absPosition=a.get(0);
     s.lonePosition=a.get(1);
     s.onePosition=a.get(2);
     s.somePosition=a.get(3);
   }
 :};

SigQual  ::= ABSTRACT:x               {: RESULT=new ArrayList<Pos>(4); RESULT.add(x);    RESULT.add(null); RESULT.add(null); RESULT.add(null); :};
SigQual  ::= LONE:x                   {: RESULT=new ArrayList<Pos>(4); RESULT.add(null); RESULT.add(x);    RESULT.add(null); RESULT.add(null); :};
SigQual  ::= ONE:x                    {: RESULT=new ArrayList<Pos>(4); RESULT.add(null); RESULT.add(null); RESULT.add(x);    RESULT.add(null); :};
SigQual  ::= SOME:x                   {: RESULT=new ArrayList<Pos>(4); RESULT.add(null); RESULT.add(null); RESULT.add(null); RESULT.add(x);    :};

SigQuals ::=                          {: RESULT=new ArrayList<Pos>(4); RESULT.add(null); RESULT.add(null); RESULT.add(null); RESULT.add(null); :};
SigQuals ::= SigQuals:a SigQual:b     {: RESULT=a; for(int i=0;i<4;i++) if (a.get(i)==null) a.set(i,b.get(i)); else if (b.get(i)!=null) throw new ErrorSyntax(b.get(i), "The same qualifer cannot be specified more than once for the same sig."); :};

SigIn    ::= EXTENDS:e Name:a         {: RESULT=new Pair<Pos,List<String>>(e.merge(a.pos), new ArrayList<String>()); RESULT.b.add(null); RESULT.b.add(a.label); :};
SigIn    ::= EXTENDS:e UNIV:a         {: RESULT=new Pair<Pos,List<String>>(e.merge(a),     new ArrayList<String>()); RESULT.b.add(null); RESULT.b.add("univ");  :};
SigIn    ::= EXTENDS:e SIGINT:a       {: RESULT=new Pair<Pos,List<String>>(e.merge(a),     new ArrayList<String>()); RESULT.b.add(null); RESULT.b.add("Int");   :};
SigIn    ::= EXTENDS:e NONE:a         {: RESULT=new Pair<Pos,List<String>>(e.merge(a),     new ArrayList<String>()); RESULT.b.add(null); RESULT.b.add("none");  :};
SigIn    ::= IN:a SigRefu:b           {: RESULT=new Pair<Pos,List<String>>(a.merge(b.a),   b.b);                                                                :};
SigIn    ::=                          {: RESULT=null;                                                                                                           :};

SigRef   ::= Name:x                   {: RESULT=x;                     :};
SigRef   ::= UNIV:x                   {: RESULT=new ExprVar(x,"univ"); :};
SigRef   ::= SIGINT:x                 {: RESULT=new ExprVar(x,"Int");  :};
SigRef   ::= NONE:x                   {: RESULT=new ExprVar(x,"none"); :};

SigRefs  ::=                          {: RESULT=new ArrayList<ExprVar>(); :};
SigRefs  ::= SigRefp:x                {: RESULT=x;                      :};

SigRefp  ::= SigRef:x                 {: RESULT=new ArrayList<ExprVar>(); RESULT.add(x); :};
SigRefp  ::= SigRefp:a COMMA SigRef:b {: a.add(b); RESULT=a;                           :};

SigRefu  ::= Name:x                   {: RESULT=new Pair<Pos,List<String>>(x.pos,            new ArrayList<String>()); RESULT.b.add(x.label); :};
SigRefu  ::= UNIV:x                   {: RESULT=new Pair<Pos,List<String>>(x,                new ArrayList<String>()); RESULT.b.add("univ");  :};
SigRefu  ::= SIGINT:x                 {: RESULT=new Pair<Pos,List<String>>(x,                new ArrayList<String>()); RESULT.b.add("Int");   :};
SigRefu  ::= NONE:x                   {: RESULT=new Pair<Pos,List<String>>(x,                new ArrayList<String>()); RESULT.b.add("none");  :};
SigRefu  ::= SigRefu:a PLUS Name:b    {: RESULT=new Pair<Pos,List<String>>(a.a.merge(b.pos), a.b); RESULT.b.add(b.label);                     :};
SigRefu  ::= SigRefu:a PLUS UNIV:b    {: RESULT=new Pair<Pos,List<String>>(a.a.merge(b),     a.b); RESULT.b.add("univ");                      :};
SigRefu  ::= SigRefu:a PLUS SIGINT:b  {: RESULT=new Pair<Pos,List<String>>(a.a.merge(b),     a.b); RESULT.b.add("Int");                       :};
SigRefu  ::= SigRefu:a PLUS NONE:b    {: RESULT=new Pair<Pos,List<String>>(a.a.merge(b),     a.b); RESULT.b.add("none");                      :};

Name ::= NameHelper:x              {: RESULT=x;                                            :};
Name ::= THIS:a SLASH NameHelper:b {: RESULT=new ExprVar(a.merge(b.pos), "this/"+b.label); :};
Name ::= SEQ:a  SLASH NameHelper:b {: RESULT=new ExprVar(a.merge(b.pos), "seq/"+b.label);  :};

NameHelper ::= ID:x                     {: RESULT=x;                                                    :};
NameHelper ::= NameHelper:a SLASH ID:b  {: RESULT=new ExprVar(a.pos.merge(b.pos), a.label+"/"+b.label); :};

Names ::= Name:x                   {: RESULT=new ArrayList<ExprVar>(); RESULT.add(x);  :};
Names ::= Names:a COMMA Name:b     {: a.add(b); RESULT=a;                            :};

Decla ::= PART:k Names COLON Expr {: ExprVar.hint(k,"part"); :};

Decla ::= EXH:k Names COLON Expr {: ExprVar.hint(k,"exh"); :};

Decla ::= DISJ:k Names:a COLON Expr:b {:
  List<String> aa = new ArrayList<String>();
  for(ExprVar aaa:a) aa.add(aaa.label);
  RESULT=new EDecl(a.get(0).pos.merge(b.span()) , aa, k ,mult(b));
:};

Decla ::= Names:a COLON Expr:b {:
  List<String> aa = new ArrayList<String>();
  for(ExprVar aaa:a) aa.add(aaa.label);
  RESULT=new EDecl(a.get(0).pos.merge(b.span()) , aa, null ,mult(b));
:};

Declp ::= Declp:x COMMA Decla:y {: RESULT=x; RESULT.add(y);                       :};
Declp ::=               Decla:y {: RESULT=new ArrayList<EDecl>(); RESULT.add(y);  :};

Decls ::=                        {: RESULT=new ArrayList<EDecl>();                :};
Decls ::= Decla:x                {: RESULT=new ArrayList<EDecl>(); RESULT.add(x); :};
Decls ::= Decla:x COMMA Decls:y  {: RESULT=y; RESULT.add(0,x);                    :};
Decls ::=         COMMA Decls:y  {: RESULT=y;                                     :};

Let ::= Name:a EQUALS:o Expr:b SuperOrBar:x {:
  if (a.label.indexOf('/')>=0) throw new ErrorSyntax(a.pos, "Let variable name cannot contain \'/\'");
  if (a.label.indexOf('@')>=0) throw new ErrorSyntax(a.pos, "Let variable name cannot contain \'@\'");
  RESULT=ExprLet.make(a.pos.merge(o), a, b, x);
:};

Let ::= Name:a EQUALS:o Expr:b COMMA Let:x {:
  if (a.label.indexOf('/')>=0) throw new ErrorSyntax(a.pos, "Let variable name cannot contain \'/\'");
  if (a.label.indexOf('@')>=0) throw new ErrorSyntax(a.pos, "Let variable name cannot contain \'@\'");
  RESULT=ExprLet.make(a.pos.merge(o), a, b, x);
:};

SuperOpt ::=                               {: RESULT=null;          :};
SuperOpt ::= Super:x                       {: RESULT=x;             :};
Super    ::= LBRACE   SuperP:x RBRACE      {: RESULT=x;             :};
Super    ::= LBRACE:o          RBRACE      {: RESULT=alloyTrue(o);  :};
SuperP   ::= Expr:a                        {: RESULT=a;             :};
SuperP   ::= Expr:a SuperP:b               {: RESULT=a.and(b);      :};

SuperOrBar ::= BAR Expr:x  {: RESULT=x; :};
SuperOrBar ::= Super:x     {: RESULT=x; :};

Exprs ::=                       {: RESULT=new ArrayList<Expr>();                :};
Exprs ::= Exprp:x               {: RESULT=x;                                    :};
Exprp ::= Expr:x                {: RESULT=new ArrayList<Expr>(); RESULT.add(x); :};
Exprp ::= Exprp:a COMMA Expr:b  {: a.add(b); RESULT=a;                          :};

//=============================================================================

Expr ::= OrExpr:x                      {: RESULT=x;                                             :};
Expr ::= LET     Let:x                 {: RESULT=x;                                             :};
Expr ::= ALL2:o  Declp:a SuperOrBar:b  {: RESULT=ExprQuantt.make(o, null, ExprQuant.Op.ALL,  a, b); :};
Expr ::= NO2:o   Declp:a SuperOrBar:b  {: RESULT=ExprQuantt.make(o, null, ExprQuant.Op.NO,   a, b); :};
Expr ::= SOME2:o Declp:a SuperOrBar:b  {: RESULT=ExprQuantt.make(o, null, ExprQuant.Op.SOME, a, b); :};
Expr ::= LONE2:o Declp:a SuperOrBar:b  {: RESULT=ExprQuantt.make(o, null, ExprQuant.Op.LONE, a, b); :};
Expr ::= ONE2:o  Declp:a SuperOrBar:b  {: RESULT=ExprQuantt.make(o, null, ExprQuant.Op.ONE,  a, b); :};
Expr ::= SUM2:o  Declp:a SuperOrBar:b  {: RESULT=ExprQuantt.make(o, null, ExprQuant.Op.SUM,  a, b); :};

OrExpr  ::=               EquivExpr:b              {: RESULT=b;                            :};
OrExpr  ::= OrExpr:a OR:o EquivExpr:b              {: RESULT=ExprBinary.Op.OR.make(o,a,b); :};

EquivExpr ::=                   ImpliesExpr:b      {: RESULT=b;                             :};
EquivExpr ::= EquivExpr:a IFF:o ImpliesExpr:b      {: RESULT=ExprBinary.Op.IFF.make(o,a,b); :};

ImpliesExpr      ::= ImpliesExprClose:a            {: RESULT=a; :};
ImpliesExpr      ::= ImpliesExprOpen:a             {: RESULT=a; :};
ImpliesExprClose ::= AndExpr:a                     {: RESULT=a; :};
ImpliesExprClose ::= AndExpr:a IMPLIES   ImpliesExprClose:b ELSE ImpliesExprClose:c {: RESULT=a.ite(b,c);                         :};
ImpliesExprOpen  ::= AndExpr:a IMPLIES   ImpliesExprClose:b ELSE ImpliesExprOpen:c  {: RESULT=a.ite(b,c);                         :};
ImpliesExprOpen  ::= AndExpr:a IMPLIES:o ImpliesExpr:b                              {: RESULT=ExprBinary.Op.OR.make(o,a.not(),b); :};

AndExpr ::=                 NegExpr:b   {: RESULT=b;                   :};
AndExpr ::= AndExpr:a AND:o NegExpr:b   {: RESULT=ExprAnd.make(o,a,b); :};

NegExpr ::=       CompareExpr:b         {: RESULT=b;                          :};
NegExpr ::= NOT:o NegExpr:b             {: RESULT=ExprUnary.Op.NOT.make(o,b); :};

CompareExpr ::= CompareExpr:a EQUALS:o    UnionDiffExpr:b    {: RESULT=ExprBinary.Op.EQUALS.make(o,a,b);         :};
CompareExpr ::= CompareExpr:a IN:o        UnionDiffExpr:b    {: RESULT=ExprBinary.Op.IN.make(o,a,mult(b));       :};
CompareExpr ::= CompareExpr:a LT:o        UnionDiffExpr:b    {: RESULT=ExprBinary.Op.LT.make(o,a,b);             :};
CompareExpr ::= CompareExpr:a GT:o        UnionDiffExpr:b    {: RESULT=ExprBinary.Op.GT.make(o,a,b);             :};
CompareExpr ::= CompareExpr:a LTE:o       UnionDiffExpr:b    {: RESULT=ExprBinary.Op.LTE.make(o,a,b);            :};
CompareExpr ::= CompareExpr:a GTE:o       UnionDiffExpr:b    {: RESULT=ExprBinary.Op.GTE.make(o,a,b);            :};
CompareExpr ::= CompareExpr:a NOTEQUALS:o UnionDiffExpr:b    {: RESULT=ExprBinary.Op.EQUALS.make(o,a,b).not();   :};
CompareExpr ::= CompareExpr:a NOTIN:o     UnionDiffExpr:b    {: RESULT=ExprBinary.Op.IN.make(o,a,mult(b)).not(); :};
CompareExpr ::= CompareExpr:a NOTLT:o     UnionDiffExpr:b    {: RESULT=ExprBinary.Op.GTE.make(o,a,b);            :};
CompareExpr ::= CompareExpr:a NOTGT:o     UnionDiffExpr:b    {: RESULT=ExprBinary.Op.LTE.make(o,a,b);            :};
CompareExpr ::= CompareExpr:a NOTLTE:o    UnionDiffExpr:b    {: RESULT=ExprBinary.Op.GT.make(o,a,b);             :};
CompareExpr ::= CompareExpr:a NOTGTE:o    UnionDiffExpr:b    {: RESULT=ExprBinary.Op.LT.make(o,a,b);             :};
CompareExpr ::= ALL:o  UnionDiffExpr                         {: if (1==1) throw new ErrorSyntax(o,"The \"all x\" construct is no longer supported. If you know the range of possible values of x, consider rewriting it as \"x == set_of_all_possible_values\"."); :};
CompareExpr ::= NO:o   UnionDiffExpr:b                       {: RESULT=ExprUnary.Op.NO.make(o,b);                :};
CompareExpr ::= SOME:o UnionDiffExpr:b                       {: RESULT=ExprUnary.Op.SOME.make(o,b);              :};
CompareExpr ::= LONE:o UnionDiffExpr:b                       {: RESULT=ExprUnary.Op.LONE.make(o,b);              :};
CompareExpr ::= ONE:o  UnionDiffExpr:b                       {: RESULT=ExprUnary.Op.ONE.make(o,b);               :};
CompareExpr ::= SET:o  UnionDiffExpr:b                       {: RESULT=ExprUnary.Op.SETOF.make(o,b);             :};
CompareExpr ::= SEQ:o  UnionDiffExpr:b                       {: RESULT=ExprBinary.Op.ISSEQ_ARROW_LONE.make(o, Sig.SEQIDX, b); parser.alloymodule.addOpen(o, "util/sequniv", new ArrayList<ExprVar>(), "seq"); :};
CompareExpr ::=        UnionDiffExpr:b                       {: RESULT=b;                                        :};

UnionDiffExpr ::=                         NumUnopExpr:b  {: RESULT=b;                               :};
UnionDiffExpr ::= UnionDiffExpr:a PLUS:o  NumUnopExpr:b  {: RESULT=ExprBinary.Op.PLUS.make(o,a,b);  :};
UnionDiffExpr ::= UnionDiffExpr:a MINUS:o NumUnopExpr:b  {: RESULT=ExprBinary.Op.MINUS.make(o,a,b); :};

NumUnopExpr ::=          OverrideExpr:b      {: RESULT=b;                                  :};
NumUnopExpr ::= HASH:o   NumUnopExpr:b       {: RESULT=ExprUnary.Op.CARDINALITY.make(o,b); :};
NumUnopExpr ::= SUM:o    NumUnopExpr:b       {: RESULT=ExprUnary.Op.CAST2INT.make(o,b);    :};
NumUnopExpr ::= INT:o    NumUnopExpr:b       {: RESULT=ExprUnary.Op.CAST2INT.make(o,b);    :};

OverrideExpr ::=                           IntersectExpr:b   {: RESULT=b;                                  :};
OverrideExpr ::= OverrideExpr:a PLUSPLUS:o IntersectExpr:b   {: RESULT=ExprBinary.Op.PLUSPLUS.make(o,a,b); :};

IntersectExpr ::=                             RelationExpr:b {: RESULT=b;                                   :};
IntersectExpr ::= IntersectExpr:a AMPERSAND:o RelationExpr:b {: RESULT=ExprBinary.Op.INTERSECT.make(o,a,b); :};

RelationExpr ::= DomainExpr:a                                  {: RESULT=a;                                         :};
RelationExpr ::= DomainExpr:a ARROW:o           RelationExpr:b {: RESULT=ExprBinary.Op.ARROW          .make(o,a,b); :};
RelationExpr ::= DomainExpr:a ANY_ARROW_SOME:o  RelationExpr:b {: RESULT=ExprBinary.Op.ANY_ARROW_SOME .make(o,a,b); :};
RelationExpr ::= DomainExpr:a ANY_ARROW_ONE:o   RelationExpr:b {: RESULT=ExprBinary.Op.ANY_ARROW_ONE  .make(o,a,b); :};
RelationExpr ::= DomainExpr:a ANY_ARROW_LONE:o  RelationExpr:b {: RESULT=ExprBinary.Op.ANY_ARROW_LONE .make(o,a,b); :};
RelationExpr ::= DomainExpr:a SOME_ARROW_ANY:o  RelationExpr:b {: RESULT=ExprBinary.Op.SOME_ARROW_ANY .make(o,a,b); :};
RelationExpr ::= DomainExpr:a SOME_ARROW_SOME:o RelationExpr:b {: RESULT=ExprBinary.Op.SOME_ARROW_SOME.make(o,a,b); :};
RelationExpr ::= DomainExpr:a SOME_ARROW_ONE:o  RelationExpr:b {: RESULT=ExprBinary.Op.SOME_ARROW_ONE .make(o,a,b); :};
RelationExpr ::= DomainExpr:a SOME_ARROW_LONE:o RelationExpr:b {: RESULT=ExprBinary.Op.SOME_ARROW_LONE.make(o,a,b); :};
RelationExpr ::= DomainExpr:a ONE_ARROW_ANY:o   RelationExpr:b {: RESULT=ExprBinary.Op.ONE_ARROW_ANY  .make(o,a,b); :};
RelationExpr ::= DomainExpr:a ONE_ARROW_SOME:o  RelationExpr:b {: RESULT=ExprBinary.Op.ONE_ARROW_SOME .make(o,a,b); :};
RelationExpr ::= DomainExpr:a ONE_ARROW_ONE:o   RelationExpr:b {: RESULT=ExprBinary.Op.ONE_ARROW_ONE  .make(o,a,b); :};
RelationExpr ::= DomainExpr:a ONE_ARROW_LONE:o  RelationExpr:b {: RESULT=ExprBinary.Op.ONE_ARROW_LONE .make(o,a,b); :};
RelationExpr ::= DomainExpr:a LONE_ARROW_ANY:o  RelationExpr:b {: RESULT=ExprBinary.Op.LONE_ARROW_ANY .make(o,a,b); :};
RelationExpr ::= DomainExpr:a LONE_ARROW_SOME:o RelationExpr:b {: RESULT=ExprBinary.Op.LONE_ARROW_SOME.make(o,a,b); :};
RelationExpr ::= DomainExpr:a LONE_ARROW_ONE:o  RelationExpr:b {: RESULT=ExprBinary.Op.LONE_ARROW_ONE .make(o,a,b); :};
RelationExpr ::= DomainExpr:a LONE_ARROW_LONE:o RelationExpr:b {: RESULT=ExprBinary.Op.LONE_ARROW_LONE.make(o,a,b); :};

DomainExpr ::=                       RangeExpr:b  {: RESULT=b;                                :};
DomainExpr ::= DomainExpr:a DOMAIN:o RangeExpr:b  {: RESULT=ExprBinary.Op.DOMAIN.make(o,a,b); :};

RangeExpr ::=                     BracketExpr:b   {: RESULT=b;                               :};
RangeExpr ::= RangeExpr:a RANGE:o BracketExpr:b   {: RESULT=ExprBinary.Op.RANGE.make(o,a,b); :};

BracketExpr ::= DotExpr:b                               {: RESULT=b;                                                                                                     :};
BracketExpr ::= BracketExpr:a LBRACKET Exprs:b RBRACKET {: Expr aa=a;                     for(Expr bb:b) aa=t(ExprCallOrJoin.make(aa.span().merge(bb.span()), bb, aa)); RESULT=aa; :};
BracketExpr ::= DISJ:a        LBRACKET Exprs:b RBRACKET {: Expr aa=new ExprVar(a,"disj"); for(Expr bb:b) aa=t(ExprCallOrJoin.make(aa.span().merge(bb.span()), bb, aa)); RESULT=aa; :};
BracketExpr ::= INT:a         LBRACKET Exprs:b RBRACKET {: Expr aa=new ExprVar(a,"int");  for(Expr bb:b) aa=t(ExprCallOrJoin.make(aa.span().merge(bb.span()), bb, aa)); RESULT=aa; :};
BracketExpr ::= SUM:a         LBRACKET Exprs:b RBRACKET {: Expr aa=new ExprVar(a,"int");  for(Expr bb:b) aa=t(ExprCallOrJoin.make(aa.span().merge(bb.span()), bb, aa)); RESULT=aa; :};

DotExpr ::=                     UnopExpr:b {: RESULT=b;                                        :};
DotExpr ::= BracketExpr:a DOT:o UnopExpr:b {: RESULT=t(ExprCallOrJoin.make(o,a,b));                     :};
DotExpr ::= BracketExpr:a DOT:o DISJ:b     {: RESULT=t(ExprCallOrJoin.make(o,a,new ExprVar(b,"disj"))); :};
DotExpr ::= BracketExpr:a DOT:o INT        {: RESULT=ExprUnary.Op.CAST2INT.make(o,a);          :};
DotExpr ::= BracketExpr:a DOT:o SUM        {: RESULT=ExprUnary.Op.CAST2INT.make(o,a);          :};

UnopExpr ::=          BaseExpr:b  {: RESULT=b;                                :};
UnopExpr ::= TILDE:o  UnopExpr:b  {: RESULT=ExprUnary.Op.TRANSPOSE.make(o,b); :};
UnopExpr ::= STAR:o   UnopExpr:b  {: RESULT=ExprUnary.Op.RCLOSURE.make(o,b);  :};
UnopExpr ::= CARET:o  UnopExpr:b  {: RESULT=ExprUnary.Op.CLOSURE.make(o,b);   :};

//=============================================================================

BaseExpr ::= NUMBER:x                               {: RESULT=x;                                                              :};
BaseExpr ::= IDEN:x                                 {: RESULT=ExprConstant.Op.IDEN.make(x,0);        :};
BaseExpr ::= UNIV:x                                 {: RESULT=ExprUnary.Op.NOOP.make(x, Sig.UNIV);   :};
BaseExpr ::= SIGINT:x                               {: RESULT=ExprUnary.Op.NOOP.make(x, Sig.SIGINT); :};
BaseExpr ::= SEQ:a SLASH SIGINT:b                   {: RESULT=ExprUnary.Op.NOOP.make(a.merge(b), Sig.SEQIDX); :};
BaseExpr ::= NONE:x                                 {: RESULT=ExprUnary.Op.NOOP.make(x, Sig.NONE);  :};
BaseExpr ::= THIS:o                                 {: RESULT=new ExprVar(o,"this");                :};
BaseExpr ::= LPAREN Expr:x RPAREN                   {: RESULT=x;                                    :};
BaseExpr ::= AT:o Name:x                            {: RESULT=new ExprVar(o, "@"+x.label);          :};
BaseExpr ::= Name:x                                 {: RESULT=x;                                                              :};
BaseExpr ::= Super:x                                {: RESULT=x;                                                              :};
BaseExpr ::= LBRACE:o Declp:a SuperOrBar:b RBRACE:c {: RESULT=ExprQuantt.make(o, c, ExprQuant.Op.COMPREHENSION, a, b);            :};
BaseExpr ::= LBRACE:o Declp:a              RBRACE:c {: RESULT=ExprQuantt.make(o, c, ExprQuant.Op.COMPREHENSION, a, alloyTrue(c)); :};

//=============================================================================
