import java.util.Stack;
import java.util.List;
import java.util.ArrayList;
import java.util.TreeSet;
import java.util.Map;
import java.util.LinkedHashMap;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.Reader;
import java.io.InputStreamReader;
import java.io.FileNotFoundException;
import java.io.UnsupportedEncodingException;
import java.io.IOException;
import java_cup.runtime.*;
import edu.mit.csail.sdg.alloy4.core.Expr;
import edu.mit.csail.sdg.alloy4.core.ExprBinary;
import edu.mit.csail.sdg.alloy4.core.ExprConstant;
import edu.mit.csail.sdg.alloy4.core.ExprITE;
import edu.mit.csail.sdg.alloy4.core.ExprJoin;
import edu.mit.csail.sdg.alloy4.core.ExprLet;
import edu.mit.csail.sdg.alloy4.core.ExprName;
import edu.mit.csail.sdg.alloy4.core.ExprQuant;
import edu.mit.csail.sdg.alloy4.core.ExprSequence;
import edu.mit.csail.sdg.alloy4.core.ExprUnary;
import edu.mit.csail.sdg.alloy4.core.ParaSig;
import edu.mit.csail.sdg.alloy4.core.ParaOpen;
import edu.mit.csail.sdg.alloy4.core.Unit;
import edu.mit.csail.sdg.alloy4.core.VarDecl;
import edu.mit.csail.sdg.alloy4.util.Err;
import edu.mit.csail.sdg.alloy4.util.ErrorInternal;
import edu.mit.csail.sdg.alloy4.util.ErrorSyntax;
import edu.mit.csail.sdg.alloy4.util.Pos;

//===========================================================================//

parser code {:

  public Unit alloyunit=null;
  public String alloyfile="";

  private Pos alloypos(Symbol x) {
    if (x==null) return null;
    if (x.value instanceof Pos) return (Pos)(x.value);
    if (x.value instanceof Expr) return ((Expr)(x.value)).pos;
    return null;
  }

  public void syntax_error(Symbol x) {
    Map<Integer,String> ch=new LinkedHashMap<Integer,String>();
    ch.put(AlloySym.ABSTRACT        , "abstract");
    ch.put(AlloySym.ALL             , "all");
    ch.put(AlloySym.ALL2            , "all");
    ch.put(AlloySym.ANY_ARROW_LONE  , "set");
    ch.put(AlloySym.ANY_ARROW_ONE   , "set");
    ch.put(AlloySym.ANY_ARROW_SOME  , "set");
    ch.put(AlloySym.AS              , "as");
    ch.put(AlloySym.ASSERT          , "assert");
    ch.put(AlloySym.BUT             , "but");
    ch.put(AlloySym.CHECK           , "check");
    ch.put(AlloySym.ELSE            , "else");
    ch.put(AlloySym.EXACTLY         , "exactly");
    ch.put(AlloySym.EXPECT          , "expect");
    ch.put(AlloySym.EXTENDS         , "extends");
    ch.put(AlloySym.FACT            , "fact");
    ch.put(AlloySym.FOR             , "for");
    ch.put(AlloySym.FUN             , "fun");
    ch.put(AlloySym.ID              , "NAME");
    ch.put(AlloySym.IDEN            , "iden");
    ch.put(AlloySym.IN              , "in");
    ch.put(AlloySym.INT             , "int");
    ch.put(AlloySym.LET             , "let");
    ch.put(AlloySym.LONE            , "lone");
    ch.put(AlloySym.LONE2           , "lone");
    ch.put(AlloySym.LONE_ARROW_ANY  , "lone");
    ch.put(AlloySym.LONE_ARROW_LONE , "lone");
    ch.put(AlloySym.LONE_ARROW_ONE  , "lone");
    ch.put(AlloySym.LONE_ARROW_SOME , "lone");
    ch.put(AlloySym.MODULE          , "module");
    ch.put(AlloySym.NO              , "no");
    ch.put(AlloySym.NO2             , "no");
    ch.put(AlloySym.NONE            , "none");
    ch.put(AlloySym.NUMBER          , "NUMBER");
    ch.put(AlloySym.ONE             , "one");
    ch.put(AlloySym.ONE2            , "one");
    ch.put(AlloySym.ONE_ARROW_ANY   , "one");
    ch.put(AlloySym.ONE_ARROW_LONE  , "one");
    ch.put(AlloySym.ONE_ARROW_ONE   , "one");
    ch.put(AlloySym.ONE_ARROW_SOME  , "one");
    ch.put(AlloySym.OPEN            , "open");
    ch.put(AlloySym.PRED            , "pred");
    ch.put(AlloySym.RUN             , "run");
    ch.put(AlloySym.SET             , "set");
    ch.put(AlloySym.SIG             , "sig");
    ch.put(AlloySym.SIGINT          , "Int");
    ch.put(AlloySym.SOME            , "some");
    ch.put(AlloySym.SOME2           , "some");
    ch.put(AlloySym.SOME_ARROW_ANY  , "some");
    ch.put(AlloySym.SOME_ARROW_LONE , "some");
    ch.put(AlloySym.SOME_ARROW_ONE  , "some");
    ch.put(AlloySym.SOME_ARROW_SOME , "some");
    ch.put(AlloySym.SUM             , "sum");
    ch.put(AlloySym.SUM2            , "sum");
    ch.put(AlloySym.THIS            , "this");
    ch.put(AlloySym.UNIV            , "univ");
    ch.put(AlloySym.AMPERSAND       , "&");
    ch.put(AlloySym.AND             , "&&");
    ch.put(AlloySym.ARROW           , "->");
    ch.put(AlloySym.AT              , "@");
    ch.put(AlloySym.BAR             , "|");
    ch.put(AlloySym.CARET           , "^");
    ch.put(AlloySym.COLON           , ":");
    ch.put(AlloySym.COMMA           , ",");
    ch.put(AlloySym.DOLLAR          , "$");
    ch.put(AlloySym.DOMAIN          , "<:");
    ch.put(AlloySym.DOT             , ".");
    ch.put(AlloySym.EQUALS          , "=");
    ch.put(AlloySym.GT              , ">");
    ch.put(AlloySym.GTE             , ">=");
    ch.put(AlloySym.HASH            , "#");
    ch.put(AlloySym.IFF             , "<=>");
    ch.put(AlloySym.IMPLIES         , "->");
    ch.put(AlloySym.LBRACE          , "{");
    ch.put(AlloySym.LBRACKET        , "[");
    ch.put(AlloySym.LPAREN          , "(");
    ch.put(AlloySym.LT              , "<");
    ch.put(AlloySym.LTE             , "=<");
    ch.put(AlloySym.MINUS           , "-");
    ch.put(AlloySym.NOT             , "!");
    ch.put(AlloySym.NOTEQUALS       , "!");
    ch.put(AlloySym.NOTGT           , "!");
    ch.put(AlloySym.NOTGTE          , "!");
    ch.put(AlloySym.NOTIN           , "!");
    ch.put(AlloySym.NOTLT           , "!");
    ch.put(AlloySym.NOTLTE          , "!");
    ch.put(AlloySym.OR              , "||");
    ch.put(AlloySym.PLUS            , "+");
    ch.put(AlloySym.PLUSPLUS        , "++");
    ch.put(AlloySym.RANGE           , ":>");
    ch.put(AlloySym.RBRACE          , "}");
    ch.put(AlloySym.RBRACKET        , "]");
    ch.put(AlloySym.RPAREN          , ")");
    ch.put(AlloySym.SLASH           , "/");
    ch.put(AlloySym.STAR            , "*");
    ch.put(AlloySym.TILDE           , "~");
    TreeSet<String> list=new TreeSet<String>();
    Pos p=alloypos(x);
    if (!stack.empty()) for(Map.Entry<Integer,String> e:ch.entrySet()) {
        int key=e.getKey(), act=get_action(((Symbol)stack.peek()).parse_state, key);
        if (act==0) continue;
        if (act>0 || alloy_confirm(key)) list.add(e.getValue());
    }
    String result="There are "+list.size()+" possible tokens that can appear here:";
    for(String item:list) result=result+" "+item;
    throw new ErrorSyntax(p, (list.size()!=0)?result:"");
  }

  private boolean alloy_confirm(int key) {
    int state = ((Symbol)stack.peek()).parse_state;
    Stack<Object> newstack=new Stack<Object>(); for(Object x:stack) newstack.push(x);
    while(true) {
      int act = get_action(state, key);
      if (act>0) return true;
      if (act==0) return false;
      int lhs_sym_num = production_tab[(-act)-1][0];
      int handle_size = production_tab[(-act)-1][1];
      for (int i = 0; i < handle_size; i++) { if (newstack.empty()) return false; newstack.pop(); }
      if (newstack.empty()) return false;
      if (newstack.peek() instanceof Symbol) state=((Symbol)newstack.peek()).parse_state;
      state=get_reduce(state, lhs_sym_num);
      newstack.push(null);
    }
  }

  public static Unit alloy_parseFile(String name, String prefix) {
    Unit u=new Unit(prefix);
    FileInputStream fis=null;
    InputStreamReader isr=null;
    AlloyFilter s=null;
    while(true) {
      if (name.length()==0) {
        BufferedReader z=new BufferedReader(new InputStreamReader(System.in));
        s=new AlloyFilter("",z);
      }
      else {
        try { fis=new FileInputStream(name); } catch(FileNotFoundException x) { break; }
        try { isr=new InputStreamReader(fis,"ISO8859_1"); } catch(UnsupportedEncodingException x) { break; }
        s=new AlloyFilter(name,isr);
      }
      AlloyParser p=new AlloyParser(s);
      p.alloyunit=u; p.alloyfile=name;
      try {p.parse(); s.close();}
        catch(Err e) {throw e;}
        catch(Exception e) {u=null;}
      break;
    }
    // The number of files we can open concurrently is a very scarse OS resource,
    // so we really need to make best effort to close all the input streams.
    try { if (s!=null) s.close(); } catch(IOException x) {u=null;}
    try { if (isr!=null) isr.close(); } catch(IOException x) {u=null;}
    try { if (fis!=null) fis.close(); } catch(IOException x) {u=null;}
    if (u==null) throw new ErrorInternal(new Pos(name,1,1),null,"Failed to parse the file \""+name+"\"");
    return u;
  }

  public static Unit alloy_parseStream(Reader isr) {
    String prefix="";
    Unit u=new Unit(prefix);
    AlloyFilter s=null;
    while(true) {
      s=new AlloyFilter("",isr);
      AlloyParser p=new AlloyParser(s);
      p.alloyunit=u; p.alloyfile="";
      try {p.parse(); s.close();}
        catch(Err e) {throw e;}
        catch(Exception e) {u=null;}
      break;
    }
    // The number of files we can open concurrently is a very scarse OS resource,
    // so we really need to make best effort to close all the input streams.
    try { if (s!=null) s.close(); } catch(IOException x) {u=null;}
    try { if (isr!=null) isr.close(); } catch(IOException x) {u=null;}
    if (u==null) throw new ErrorInternal(new Pos("",1,1),null,"Parser failed to parse this input!");
    return u;
  }

  public static ArrayList<Unit> alloy_totalparseFile (String name) {
      ArrayList<Unit> units=new ArrayList<Unit>();
      ArrayList<String> thispath=new ArrayList<String>();
      alloy_totalparseHelper(new Pos(name,1,1), name, "", units, thispath);
      return units;
  }

  public static ArrayList<Unit> alloy_totalparseStream (Reader i) {
      ArrayList<Unit> units=new ArrayList<Unit>();
      ArrayList<String> thispath=new ArrayList<String>();
      Unit u=AlloyParser.alloy_parseStream(i);
      units.add(u);
      for(Map.Entry<String, ParaOpen> opens:u.opencmds.entrySet()) {
          // Here, we recursively open the included files (to fill out the "Unit.opens" field)
          ParaOpen y=opens.getValue();
          Unit uu=alloy_totalparseHelper(y.pos, y.filename, y.name, units, thispath);
          if (y.list.size() != uu.params.size()) throw y.syntaxError("You supplied "+y.list.size()+" arguments to the import statement, but the imported module requires "+uu.params.size()+" arguments!");
          u.opens.put(y.name, uu);
      }
      return units;
  }

  private static Unit alloy_totalparseHelper(Pos pos,String name,String prefix,ArrayList<Unit> units,ArrayList<String> thispath) {
      // Figure out the exact filename
      File f=new File(name);
      if (!f.exists()) f=new File("models/"+name+".als");
      if (!f.exists()) throw new ErrorSyntax(pos, "The module \""+name+"\" cannot be found!");
      // Add the filename into a ArrayList, so that we can detect cycles in the module import graph
      // How? I'll argue that (filename appears > 1 time along a chain) <=> (infinite loop in the import graph)
      // => As you descend down the chain via OPEN, if you see the same FILE twice, then
      //    you will go into an infinite loop (since, regardless of the instantiating parameter,
      //    that file will attempt to OPEN the exact same set of files. leading back to itself, etc. etc.)
      // <= If there is an infinite loop, that means there is at least 1 infinite chain of OPEN (from root).
      //    Since the number of files is finite, at least 1 filename will be repeated.
      String absolutePath=f.getAbsolutePath();
      if (thispath.contains(absolutePath)) throw new ErrorSyntax(pos,"Circular dependency in module import! The file \""+absolutePath+"\" is imported infinitely often!");
      thispath.add(absolutePath);
      // No cycle detected so far. So now we parse the file.
      Unit u=AlloyParser.alloy_parseFile(absolutePath,prefix);
      units.add(u);
      // The returned Unit object is fully-filled-in except
      // * Unit.{opens,params}
      // * Sig.{type,sup,sups,subs}
      // * Field.halftype, Field.Full.fulltype, Expr*.type, and ExprName.resolved
      // Also, there will not be any ExprCall. Only ExprJoin.
      for(Map.Entry<String, ParaOpen> opens:u.opencmds.entrySet()) {
          // Here, we recursively open the included files (to fill out the "Unit.opens" field)
          ParaOpen y=opens.getValue();
          Unit uu=alloy_totalparseHelper(y.pos, y.filename, prefix.length()==0 ? y.name : prefix+"/"+y.name, units, thispath);
          if (y.list.size() != uu.params.size()) throw y.syntaxError("You supplied "+y.list.size()+" arguments to the import statement, but the imported module requires "+uu.params.size()+" arguments!");
          u.opens.put(y.name, uu);
      }
      thispath.remove(thispath.size()-1); // Remove this file from the CYCLE DETECTION LIST.
      return u;
  }

:};

action code {:
    /**
     * This function is needed to handle a difficult parsing ambiguity.
     *
     * <p/>
     * "some EXPR", "one EXPR", and "lone EXPR"
     * can be either formulas (saying the EXPR has at least 1, exactly 1, or at most 1 tuple),
     * or multiplicity constraints (saying something else has this multiplicity).
     *
     * <p/>
     * So we let the parser generate the former by default.
     * And whenever we construct a VarDecl(x,y) object,
     * or an ExprBinary.Op.IN(x,y) object, or a function return type,
     * we call this method on y to convert it into a multiplicity constraint.
     *
     * <p/>
     * This is safe, because in all 3 cases, a formula would be illegal.
     * So the first form is always wrong.
     *
     * <p/>
     * And this is sufficient, because those are the only 3 places
     * where a mulitplicity constraint is allowed to appear.
     *
     * @return a newly formed multiplciity constraint (if this.op==SOME or LONE or ONE),
     * otherwise it just returns the original node.
     */
    private Expr mult(Expr x) {
        if (x instanceof ExprUnary) {
           ExprUnary y=(ExprUnary)x;
           if (y.op==ExprUnary.Op.SOME) return ExprUnary.Op.SOMEMULT.make(y.pos, y.sub);
           if (y.op==ExprUnary.Op.LONE) return ExprUnary.Op.LONEMULT.make(y.pos, y.sub);
           if (y.op==ExprUnary.Op.ONE) return ExprUnary.Op.ONEMULT.make(y.pos, y.sub);
        }
        return x;
    }
:};

//===========================================================================//

terminal Pos ANY_ARROW_SOME;   //  ->some    // The filter allows whitespace/comment in these 15 "*->*" tokens
terminal Pos ANY_ARROW_ONE;    //  ->one
terminal Pos ANY_ARROW_LONE;   //  ->lone
terminal Pos SOME_ARROW_ANY;   //  some->
terminal Pos SOME_ARROW_SOME;  //  some->some
terminal Pos SOME_ARROW_ONE;   //  some->one
terminal Pos SOME_ARROW_LONE;  //  some->lone
terminal Pos ONE_ARROW_ANY;    //  one->
terminal Pos ONE_ARROW_SOME;   //  one->some
terminal Pos ONE_ARROW_ONE;    //  one->one
terminal Pos ONE_ARROW_LONE;   //  one->lone
terminal Pos LONE_ARROW_ANY;   //  lone->any
terminal Pos LONE_ARROW_SOME;  //  lone->some
terminal Pos LONE_ARROW_ONE;   //  lone->one
terminal Pos LONE_ARROW_LONE;  //  lone->lone

terminal Pos ABSTRACT;         //  abstract
terminal Pos ALL;              //  all      // The filter enables us to disambiguate
terminal Pos ALL2;             //  all      // The filter enables us to disambiguate
terminal Pos AMPERSAND;        //  &
terminal Pos AND;              //  && and
terminal Pos ARROW;            //  ->
terminal Pos AS;               //  as
terminal Pos ASSERT;           //  assert
terminal Pos AT;               //  @
terminal Pos BAR;              //  |
terminal Pos BUT;              //  but
terminal Pos CARET;            //  ^
terminal Pos CHECK;            //  check
terminal Pos COLON;            //  :
terminal Pos COMMA;            //  ,
terminal Pos DISJ;             //  disj disjoint
terminal Pos DOLLAR;           //  $
terminal Pos DOMAIN;           //  <:
terminal Pos DOT;              //  .
terminal Pos ELSE;             //  else
terminal Pos EQUALS;           //  =  ==
terminal Pos EXACTLY;          //  exactly
terminal Pos EXH;              //  exh exhaustive
terminal Pos EXPECT;           //  expect
terminal Pos EXTENDS;          //  extends
terminal Pos FACT;             //  fact
terminal Pos FOR;              //  for
terminal Pos FUN;              //  fun
terminal Pos GT;               //  >
terminal Pos GTE;              //  >=
terminal Pos HASH;             //  #
terminal Pos IDEN;             //  iden
terminal Pos IFF;              //  <=> iff
terminal Pos IMPLIES;          //  => implies
terminal Pos IN;               //  in
terminal Pos INT;              //  int
terminal Pos LBRACE;           //  {
terminal Pos LBRACKET;         //  [
terminal Pos LET;              //  let
terminal Pos LONE2;            //  lone      // The filter enables us to disambiguate
terminal Pos LONE;             //  lone      // The filter enables us to disambiguate
terminal Pos LPAREN;           //  (
terminal Pos LT;               //  <
terminal Pos LTE;              //  =<
terminal Pos MINUS;            //  -
terminal Pos MODULE;           //  module
terminal Pos NO2;              //  no        // The filter enables us to disambiguate
terminal Pos NO;               //  no        // The filter enables us to disambiguate
terminal Pos NONE;             //  none
terminal Pos NOT;              //  !      not
terminal Pos NOTEQUALS;        //  !=     not=    // The filter allows whitespace/comment in between
terminal Pos NOTGT;            //  !>     not>    // The filter allows whitespace/comment in between
terminal Pos NOTGTE;           //  !>=    not>=   // The filter allows whitespace/comment in between
terminal Pos NOTIN;            //  !in    notin   // The filter allows whitespace/comment in between
terminal Pos NOTLT;            //  !<     not<    // The filter allows whitespace/comment in between
terminal Pos NOTLTE;           //  !=<    not=<   // The filter allows whitespace/comment in between
terminal Pos ONE2;             //  one            // The filter enables us to disambiguate
terminal Pos ONE;              //  one            // The filter enables us to disambiguate
terminal Pos OPEN;             //  open
terminal Pos OR;               //  ||     or
terminal Pos PART;             //  part   partition
terminal Pos PLUS;             //  +
terminal Pos PLUSPLUS;         //  ++
terminal Pos PRED;             //  pred
terminal Pos RANGE;            //  :>
terminal Pos RBRACE;           //  }
terminal Pos RBRACKET;         //  ]
terminal Pos RPAREN;           //  )
terminal Pos RUN;              //  run
terminal Pos SET;              //  set
terminal Pos SIG;              //  sig
terminal Pos SIGINT;           //  Int
terminal Pos SLASH;            //  /
terminal Pos SOME2;            //  some      // The filter enables us to disambiguate
terminal Pos SOME;             //  some      // The filter enables us to disambiguate
terminal Pos STAR;             //  *
terminal Pos SUM2;             //  sum       // The filter enables us to disambiguate
terminal Pos SUM;              //  sum       // The filter enables us to disambiguate
terminal Pos THIS;             //  this
terminal Pos TILDE;            //  ~
terminal Pos UNIV;             //  univ

terminal ExprName  ID;
terminal Expr      NUMBER;

//===========================================================================//

nonterminal Expr                       AndExpr;
nonterminal Expr                       BaseExpr;
nonterminal Expr                       BracketExpr;
nonterminal Expr                       CompareExpr;
nonterminal List<VarDecl>              Declp;
nonterminal List<VarDecl>              Decls;
nonterminal Expr                       DomainExpr;
nonterminal Expr                       DotExpr;
nonterminal Expr                       EquivExpr;
nonterminal String                     Expects;
nonterminal Expr                       Expr;
nonterminal Expr                       ExprPara;
nonterminal Expr                       ExprParaOpt;
nonterminal List<Expr>                 ExprParas;
nonterminal Expr                       ExprParaOrBar;
nonterminal List<Expr>                 Exprs;
nonterminal List<Expr>                 Exprp;
nonterminal                            Function;
nonterminal Expr                       ImpliesExpr;
nonterminal Expr                       ImpliesExprClose;
nonterminal Expr                       ImpliesExprOpen;
nonterminal Expr                       IntersectExpr;
nonterminal ExprLet                    Let;
nonterminal                            Module;
nonterminal ExprName                   Name;
nonterminal ExprName                   NameHelper;
nonterminal List<ExprName>             Names;
nonterminal Expr                       NegExpr;
nonterminal Expr                       NumUnopExpr;
nonterminal                            Open;
nonterminal                            Opens;
nonterminal Expr                       OrExpr;
nonterminal Expr                       OverrideExpr;
nonterminal                            Paragraphs;
nonterminal                            Predicate;
nonterminal Expr                       RangeExpr;
nonterminal Expr                       RelationExpr;
nonterminal List<String>               Scope;
nonterminal                            Sig;
nonterminal List<String>               SigIn;
nonterminal Integer                    SigQual;
nonterminal Integer                    SigQuals;
nonterminal ExprName                   SigRef;
nonterminal List<ExprName>             SigRefp;
nonterminal List<ExprName>             SigRefs;
nonterminal List<String>               SigRefu;
nonterminal                            Specification;
nonterminal List<String>               Typescopes;
nonterminal List<String>               Typescope;
nonterminal Expr                       UnionDiffExpr;
nonterminal Expr                       UnopExpr;

//===========================================================================//

Specification ::= Module Opens Paragraphs ;

Module ::= MODULE:o Name                           {: parser.alloyunit.makeModule(o                            , new ArrayList<ExprName>()); :};
Module ::= MODULE:o Name LBRACKET Names:b RBRACKET {: parser.alloyunit.makeModule(o                            , b                        ); :};
Module ::=                                         {: parser.alloyunit.makeModule(new Pos(parser.alloyfile,1,1), new ArrayList<ExprName>()); :};

Open ::= OPEN:o Name:a                                        {: parser.alloyunit.makeOpen(o, a.name, new ArrayList<ExprName>(), "");     :};
Open ::= OPEN:o Name:a                             AS Name:c  {: parser.alloyunit.makeOpen(o, a.name, new ArrayList<ExprName>(), c.name); :};
Open ::= OPEN:o Name:a LBRACKET SigRefs:b RBRACKET            {: parser.alloyunit.makeOpen(o, a.name, b, "");                             :};
Open ::= OPEN:o Name:a LBRACKET SigRefs:b RBRACKET AS Name:c  {: parser.alloyunit.makeOpen(o, a.name, b, c.name);                         :};

Opens ::=            ;
Opens ::= Opens Open ;

Paragraphs ::= Paragraphs FACT:o          ExprPara:e  {: parser.alloyunit.makeFact   (o,""    ,e); :};
Paragraphs ::= Paragraphs FACT:o   Name:n ExprPara:e  {: parser.alloyunit.makeFact   (o,n.name,e); :};
Paragraphs ::= Paragraphs ASSERT:o        ExprPara:e  {: parser.alloyunit.makeAssert (o,""    ,e); :};
Paragraphs ::= Paragraphs ASSERT:o Name:n ExprPara:e  {: parser.alloyunit.makeAssert (o,n.name,e); :};

Paragraphs ::= Paragraphs Sig             ;
Paragraphs ::= Paragraphs FUN Function    ;
Paragraphs ::= Paragraphs PRED Predicate  ;
Paragraphs ::=                            ;

Paragraphs ::= Paragraphs CHECK:o  ExprPara:e  Scope:s  {:
  int overall = s.get(0).length()>0 ? Integer.parseInt(s.get(0)) : -1;
  int expects = s.get(1).length()>0 ? Integer.parseInt(s.get(1)) : -1;
  Map<String,Integer> scope=new LinkedHashMap<String,Integer>();
  for(int i=2; i<s.size()-1; i=i+2) {
    int j;
    String a=s.get(i);
    String b=s.get(i+1);
    if (a.charAt(0)=='e') { j=Integer.parseInt(a.substring(1)); j=(0-j)-1; } else { j=Integer.parseInt(a); }
    if (scope.containsKey(b)) throw new ErrorSyntax(o,"The scope of the sig \""+b+"\" cannot be specified more than once!");
    scope.put(b,j);
  }
  parser.alloyunit.makeRuncheck(o, e, true, overall, expects, scope);
:};

Paragraphs ::= Paragraphs CHECK:o  Name:n  Scope:s  {:
  int overall = s.get(0).length()>0 ? Integer.parseInt(s.get(0)) : -1;
  int expects = s.get(1).length()>0 ? Integer.parseInt(s.get(1)) : -1;
  Map<String,Integer> scope=new LinkedHashMap<String,Integer>();
  for(int i=2; i<s.size()-1; i=i+2) {
    int j;
    String a=s.get(i);
    String b=s.get(i+1);
    if (a.charAt(0)=='e') { j=Integer.parseInt(a.substring(1)); j=(0-j)-1; } else { j=Integer.parseInt(a); }
    if (scope.containsKey(b)) throw new ErrorSyntax(o,"The scope of the sig \""+b+"\" cannot be specified more than once!");
    scope.put(b,j);
  }
  parser.alloyunit.makeRuncheck(o, n.name, true, overall, expects, scope);
:};

Paragraphs ::= Paragraphs RUN:o  Name:n  Scope:s  {:
  int overall = s.get(0).length()>0 ? Integer.parseInt(s.get(0)) : -1;
  int expects = s.get(1).length()>0 ? Integer.parseInt(s.get(1)) : -1;
  Map<String,Integer> scope=new LinkedHashMap<String,Integer>();
  for(int i=2; i<s.size()-1; i=i+2) {
    int j;
    String a=s.get(i);
    String b=s.get(i+1);
    if (a.charAt(0)=='e') { j=Integer.parseInt(a.substring(1)); j=(0-j)-1; } else { j=Integer.parseInt(a); }
    if (scope.containsKey(b)) throw new ErrorSyntax(o,"The scope of the sig \""+b+"\" cannot be specified more than once!");
    scope.put(b,j);
  }
  parser.alloyunit.makeRuncheck(o, n.name, false, overall, expects, scope);
:};

Paragraphs ::= Paragraphs RUN:o  ExprPara:e  Scope:s  {:
  int overall = s.get(0).length()>0 ? Integer.parseInt(s.get(0)) : -1;
  int expects = s.get(1).length()>0 ? Integer.parseInt(s.get(1)) : -1;
  Map<String,Integer> scope=new LinkedHashMap<String,Integer>();
  for(int i=2; i<s.size()-1; i=i+2) {
    int j;
    String a=s.get(i);
    String b=s.get(i+1);
    if (a.charAt(0)=='e') { j=Integer.parseInt(a.substring(1)); j=(0-j)-1; } else { j=Integer.parseInt(a); }
    if (scope.containsKey(b)) throw new ErrorSyntax(o,"The scope of the sig \""+b+"\" cannot be specified more than once!");
    scope.put(b,j);
  }
  parser.alloyunit.makeRuncheck(o, e, false, overall, expects, scope);
:};

Expects    ::=                 {: RESULT="";                         :};
Expects    ::= EXPECT NUMBER:a {: RESULT=""+((ExprConstant)a).num(); :};

Scope      ::= FOR NUMBER:a                  Expects:c {: RESULT=new ArrayList<String>(); RESULT.add(""+((ExprConstant)a).num()); RESULT.add(c);                   :};
Scope      ::= FOR NUMBER:a BUT Typescopes:b Expects:c {: RESULT=new ArrayList<String>(); RESULT.add(""+((ExprConstant)a).num()); RESULT.add(c); RESULT.addAll(b); :};
Scope      ::= FOR              Typescopes:b Expects:c {: RESULT=new ArrayList<String>(); RESULT.add("");                         RESULT.add(c); RESULT.addAll(b); :};
Scope      ::=                               Expects:c {: RESULT=new ArrayList<String>(); RESULT.add("");                         RESULT.add(c);                   :};

Typescopes ::= Typescope:a                    {: RESULT=a;               :};
Typescopes ::= Typescopes:a COMMA Typescope:b {: RESULT=a; a.addAll(b);  :};
Typescope  ::= EXACTLY NUMBER:a Name:b        {: RESULT=new ArrayList<String>(); RESULT.add("e"+((ExprConstant)a).num()); RESULT.add(b.name);                 :};
Typescope  ::=         NUMBER:a Name:b        {: RESULT=new ArrayList<String>(); RESULT.add( ""+((ExprConstant)a).num()); RESULT.add(b.name);                 :};
Typescope  ::= EXACTLY NUMBER:a INT           {: RESULT=new ArrayList<String>(); RESULT.add("e"+((ExprConstant)a).num()); RESULT.add(ParaSig.BITWIDTH_NAME);  :};
Typescope  ::=         NUMBER:a INT           {: RESULT=new ArrayList<String>(); RESULT.add( ""+((ExprConstant)a).num()); RESULT.add(ParaSig.BITWIDTH_NAME);  :};
Typescope  ::= EXACTLY NUMBER:a SIGINT        {: RESULT=new ArrayList<String>(); RESULT.add("e"+((ExprConstant)a).num()); RESULT.add(ParaSig.SIGINT_NAME);    :};
Typescope  ::=         NUMBER:a SIGINT        {: RESULT=new ArrayList<String>(); RESULT.add( ""+((ExprConstant)a).num()); RESULT.add(ParaSig.SIGINT_NAME);    :};

Function ::=              Name:n LPAREN   Decls:d RPAREN   COLON Expr:t LBRACE Expr:v RBRACE   {: parser.alloyunit.makeFun(n.pos,n.name,null,d                       ,mult(t),v); :};
Function ::=              Name:n LBRACKET Decls:d RBRACKET COLON Expr:t LBRACE Expr:v RBRACE   {: parser.alloyunit.makeFun(n.pos,n.name,null,d                       ,mult(t),v); :};
Function ::=              Name:n                           COLON Expr:t LBRACE Expr:v RBRACE   {: parser.alloyunit.makeFun(n.pos,n.name,null,new ArrayList<VarDecl>(),mult(t),v); :};
Function ::= SigRef:f DOT Name:n LPAREN   Decls:d RPAREN   COLON Expr:t LBRACE Expr:v RBRACE   {: parser.alloyunit.makeFun(n.pos,n.name,f   ,d                       ,mult(t),v); :};
Function ::= SigRef:f DOT Name:n LBRACKET Decls:d RBRACKET COLON Expr:t LBRACE Expr:v RBRACE   {: parser.alloyunit.makeFun(n.pos,n.name,f   ,d                       ,mult(t),v); :};
Function ::= SigRef:f DOT Name:n                           COLON Expr:t LBRACE Expr:v RBRACE   {: parser.alloyunit.makeFun(n.pos,n.name,f   ,new ArrayList<VarDecl>(),mult(t),v); :};

Predicate ::=              Name:n LPAREN   Decls:d RPAREN   ExprPara:v   {: parser.alloyunit.makeFun(n.pos,n.name,null,d                       ,null,v); :};
Predicate ::=              Name:n LBRACKET Decls:d RBRACKET ExprPara:v   {: parser.alloyunit.makeFun(n.pos,n.name,null,d                       ,null,v); :};
Predicate ::=              Name:n                           ExprPara:v   {: parser.alloyunit.makeFun(n.pos,n.name,null,new ArrayList<VarDecl>(),null,v); :};
Predicate ::= SigRef:f DOT Name:n LPAREN   Decls:d RPAREN   ExprPara:v   {: parser.alloyunit.makeFun(n.pos,n.name,f   ,d                       ,null,v); :};
Predicate ::= SigRef:f DOT Name:n LBRACKET Decls:d RBRACKET ExprPara:v   {: parser.alloyunit.makeFun(n.pos,n.name,f   ,d                       ,null,v); :};
Predicate ::= SigRef:f DOT Name:n                           ExprPara:v   {: parser.alloyunit.makeFun(n.pos,n.name,f   ,new ArrayList<VarDecl>(),null,v); :};

Sig ::= SigQuals:a SIG Names:b SigIn:c LBRACE Decls:d RBRACE ExprParaOpt:e
 {:
   for(ExprName bbb:b) {
     String bb=bbb.name;
     if (c==null)
       parser.alloyunit.makeSig(bbb.pos, bb, (a&1)!=0,(a&2)!=0,(a&4)!=0,(a&8)!=0,null,null,d,e);
     else if (c.get(0)==null)
       parser.alloyunit.makeSig(bbb.pos, bb, (a&1)!=0,(a&2)!=0,(a&4)!=0,(a&8)!=0,null,(String)(c.get(1)),d,e);
     else
       parser.alloyunit.makeSig(bbb.pos, bb, (a&1)!=0,(a&2)!=0,(a&4)!=0,(a&8)!=0,c,null,d,e);
   }
 :};

SigQual  ::= ABSTRACT                 {: RESULT=1;                                                                           :};
SigQual  ::= LONE                     {: RESULT=2;                                                                           :};
SigQual  ::= ONE                      {: RESULT=4;                                                                           :};
SigQual  ::= SOME                     {: RESULT=8;                                                                           :};
SigQuals ::=                          {: RESULT=0;                                                                           :};
SigQuals ::= SigQuals:a SigQual:b     {: RESULT=(a|b);                                                                       :};
SigIn    ::= EXTENDS Name:a           {: RESULT=new ArrayList<String>(); RESULT.add(null); RESULT.add(a.name);               :};
SigIn    ::= EXTENDS SIGINT           {: RESULT=new ArrayList<String>(); RESULT.add(null); RESULT.add(ParaSig.SIGINT_NAME);  :};
SigIn    ::= IN SigRefu:b             {: RESULT=b;                                                                           :};
SigIn    ::=                          {: RESULT=null;                                                                        :};
SigRef   ::= Name:x                   {: RESULT=x;                                                                           :};
SigRef   ::= UNIV:x                   {: RESULT=new ExprName(x, ParaSig.UNIV_NAME);                                          :};
SigRef   ::= SIGINT:x                 {: RESULT=new ExprName(x, ParaSig.SIGINT_NAME);                                        :};
SigRefs  ::=                          {: RESULT=new ArrayList<ExprName>();                                                   :};
SigRefs  ::= SigRefp:x                {: RESULT=x;                                                                           :};
SigRefp  ::= SigRef:x                 {: RESULT=new ArrayList<ExprName>(); RESULT.add(x);                                    :};
SigRefp  ::= SigRefp:a COMMA SigRef:b {: a.add(b); RESULT=a;                                                                 :};
SigRefu  ::= Name:x                   {: RESULT=new ArrayList<String>(); RESULT.add(x.name);                                 :};
SigRefu  ::= SIGINT                   {: RESULT=new ArrayList<String>(); RESULT.add(ParaSig.SIGINT_NAME);                    :};
SigRefu  ::= SigRefu:a PLUS Name:b    {: RESULT=a; RESULT.add(b.name);                                                       :};
SigRefu  ::= SigRefu:a PLUS SIGINT    {: RESULT=a; RESULT.add(ParaSig.SIGINT_NAME);                                          :};

Name ::= NameHelper:x              {: RESULT=x;                               :};
Name ::= THIS:a SLASH NameHelper:b {: RESULT=new ExprName(a, "this/"+b.name); :};

NameHelper ::= ID:x                     {: RESULT=x;                                      :};
NameHelper ::= NameHelper:a SLASH ID:b  {: RESULT=new ExprName(a.pos, a.name+"/"+b.name); :};

Names ::= Name:x                   {: RESULT=new ArrayList<ExprName>(); RESULT.add(x);  :};
Names ::= Names:a COMMA Name:b     {: a.add(b); RESULT=a;                               :};

Declp ::= Declp   COMMA PART:k Names   COLON   Expr    {: ExprName.hint(k,"part");                                               :};
Declp ::= Declp   COMMA DISJ:k Names   COLON   Expr    {: ExprName.hint(k,"disj");                                               :};
Declp ::= Declp   COMMA EXH:k  Names   COLON   Expr    {: ExprName.hint(k,"exh");                                                :};
Declp ::= Declp:x COMMA        Names:a COLON:o Expr:b  {: RESULT=x; RESULT.add(new VarDecl(o,a,mult(b)));                        :};
Declp ::=               PART:k Names   COLON   Expr    {: ExprName.hint(k,"part");                                               :};
Declp ::=               DISJ:k Names   COLON   Expr    {: ExprName.hint(k,"disj");                                               :};
Declp ::=               EXH:k  Names   COLON   Expr    {: ExprName.hint(k,"exh");                                                :};
Declp ::=                      Names:a COLON:o Expr:b  {: RESULT=new ArrayList<VarDecl>(); RESULT.add(new VarDecl(o,a,mult(b))); :};

Decls ::=          {: RESULT=new ArrayList<VarDecl>(); :};
Decls ::= Declp:x  {: RESULT=x;                        :};

Let ::= Name:a EQUALS Expr:b ExprParaOrBar:x  {: RESULT=new ExprLet(a.pos,a.name,b,x); :};
Let ::= Name:a EQUALS Expr:b COMMA Let:x      {: RESULT=new ExprLet(a.pos,a.name,b,x); :};

ExprParaOpt ::=                                {: RESULT=null;                   :};
ExprParaOpt ::= ExprPara:x                     {: RESULT=x;                      :};
ExprPara    ::= LBRACE:o ExprParas:x RBRACE    {: RESULT=new ExprSequence(o,x);  :};
ExprParas   ::=                                {: RESULT=new ArrayList<Expr>();  :};
ExprParas   ::= Expr:a ExprParas:b             {: b.add(0,a); RESULT=b;          :};

ExprParaOrBar ::= BAR Expr:x    {: RESULT=x; :};
ExprParaOrBar ::= ExprPara:x    {: RESULT=x; :};

Exprs ::=                       {: RESULT=new ArrayList<Expr>();                :};
Exprs ::= Exprp:x               {: RESULT=x;                                    :};
Exprp ::= Expr:x                {: RESULT=new ArrayList<Expr>(); RESULT.add(x); :};
Exprp ::= Exprp:a COMMA Expr:b  {: a.add(b); RESULT=a;                          :};

//=============================================================================

Expr ::= OrExpr:x                         {: RESULT=x;                                  :};
Expr ::= LET     Let:x                    {: RESULT=x;                                  :};
Expr ::= ALL2:o  Declp:a ExprParaOrBar:b  {: RESULT=ExprQuant.Op.ALL .make(o,a,b,null); :};
Expr ::= NO2:o   Declp:a ExprParaOrBar:b  {: RESULT=ExprQuant.Op.NO  .make(o,a,b,null); :};
Expr ::= SOME2:o Declp:a ExprParaOrBar:b  {: RESULT=ExprQuant.Op.SOME.make(o,a,b,null); :};
Expr ::= LONE2:o Declp:a ExprParaOrBar:b  {: RESULT=ExprQuant.Op.LONE.make(o,a,b,null); :};
Expr ::= ONE2:o  Declp:a ExprParaOrBar:b  {: RESULT=ExprQuant.Op.ONE .make(o,a,b,null); :};
Expr ::= SUM2:o  Declp:a ExprParaOrBar:b  {: RESULT=ExprQuant.Op.SUM .make(o,a,b,null); :};

OrExpr  ::=               EquivExpr:b              {: RESULT=b;                              :};
OrExpr  ::= OrExpr:a OR:o EquivExpr:b              {: RESULT=ExprBinary.Op.OR.make(o,a,b);   :};

EquivExpr ::=                   ImpliesExpr:b      {: RESULT=b;                              :};
EquivExpr ::= EquivExpr:a IFF:o ImpliesExpr:b      {: RESULT=ExprBinary.Op.IFF.make(o,a,b);  :};

ImpliesExpr      ::= ImpliesExprClose:a            {: RESULT=a; :};
ImpliesExpr      ::= ImpliesExprOpen:a             {: RESULT=a; :};
ImpliesExprClose ::= AndExpr:a                     {: RESULT=a; :};
ImpliesExprClose ::= AndExpr:a IMPLIES:o ImpliesExprClose:b ELSE ImpliesExprClose:c {: RESULT=new ExprITE(o,a,b,c);              :};
ImpliesExprOpen  ::= AndExpr:a IMPLIES:o ImpliesExprClose:b ELSE ImpliesExprOpen:c  {: RESULT=new ExprITE(o,a,b,c);              :};
ImpliesExprOpen  ::= AndExpr:a IMPLIES:o ImpliesExpr:b                              {: RESULT=ExprBinary.Op.IMPLIES.make(o,a,b); :};

AndExpr ::=                 NegExpr:b                    {: RESULT=b;                                   :};
AndExpr ::= AndExpr:a AND:o NegExpr:b                    {: RESULT=ExprBinary.Op.AND.make(o,a,b);       :};

NegExpr ::= CompareExpr:b      {: RESULT=b;                          :};
NegExpr ::= NOT:o NegExpr:b    {: RESULT=ExprUnary.Op.NOT.make(o,b); :};

CompareExpr ::= CompareExpr:a EQUALS:o    UnionDiffExpr:b    {: RESULT=ExprBinary.Op.EQUALS   .make(o,a,b);                             :};
CompareExpr ::= CompareExpr:a IN:o        UnionDiffExpr:b    {: RESULT=ExprBinary.Op.IN       .make(o,a,mult(b));                       :};
CompareExpr ::= CompareExpr:a LT:o        UnionDiffExpr:b    {: RESULT=ExprBinary.Op.LT       .make(o,a,b);                             :};
CompareExpr ::= CompareExpr:a GT:o        UnionDiffExpr:b    {: RESULT=ExprBinary.Op.GT       .make(o,a,b);                             :};
CompareExpr ::= CompareExpr:a LTE:o       UnionDiffExpr:b    {: RESULT=ExprBinary.Op.LTE      .make(o,a,b);                             :};
CompareExpr ::= CompareExpr:a GTE:o       UnionDiffExpr:b    {: RESULT=ExprBinary.Op.GTE      .make(o,a,b);                             :};
CompareExpr ::= CompareExpr:a NOTEQUALS:o UnionDiffExpr:b    {: RESULT=ExprUnary.Op.NOT.make(o,ExprBinary.Op.EQUALS.make(o,a,b      )); :};
CompareExpr ::= CompareExpr:a NOTIN:o     UnionDiffExpr:b    {: RESULT=ExprUnary.Op.NOT.make(o,ExprBinary.Op.IN    .make(o,a,mult(b))); :};
CompareExpr ::= CompareExpr:a NOTLT:o     UnionDiffExpr:b    {: RESULT=ExprUnary.Op.NOT.make(o,ExprBinary.Op.LT    .make(o,a,b      )); :};
CompareExpr ::= CompareExpr:a NOTGT:o     UnionDiffExpr:b    {: RESULT=ExprUnary.Op.NOT.make(o,ExprBinary.Op.GT    .make(o,a,b      )); :};
CompareExpr ::= CompareExpr:a NOTLTE:o    UnionDiffExpr:b    {: RESULT=ExprUnary.Op.NOT.make(o,ExprBinary.Op.LTE   .make(o,a,b      )); :};
CompareExpr ::= CompareExpr:a NOTGTE:o    UnionDiffExpr:b    {: RESULT=ExprUnary.Op.NOT.make(o,ExprBinary.Op.GTE   .make(o,a,b      )); :};
CompareExpr ::= NO:o   UnionDiffExpr:b                       {: RESULT=ExprUnary .Op.NO       .make(o,b);                               :};
CompareExpr ::= SOME:o UnionDiffExpr:b                       {: RESULT=ExprUnary .Op.SOME     .make(o,b);                               :};
CompareExpr ::= LONE:o UnionDiffExpr:b                       {: RESULT=ExprUnary .Op.LONE     .make(o,b);                               :};
CompareExpr ::= ONE:o  UnionDiffExpr:b                       {: RESULT=ExprUnary .Op.ONE      .make(o,b);                               :};
CompareExpr ::= SET:o  UnionDiffExpr:b                       {: RESULT=ExprUnary .Op.SETMULT  .make(o,b);                               :};
CompareExpr ::= ALL:o  UnionDiffExpr                         {: if (1==1) throw new ErrorSyntax(o,"The \"all x\" construct is no longer supported. If you know the range of possible values of x, consider rewriting it as \"x == set_of_all_possible_values\"."); :};
CompareExpr ::=        UnionDiffExpr:b                       {: RESULT=b;                                                               :};

UnionDiffExpr ::=                         NumUnopExpr:b     {: RESULT=b;                                   :};
UnionDiffExpr ::= UnionDiffExpr:a PLUS:o  NumUnopExpr:b     {: RESULT=ExprBinary.Op.PLUS.make(o,a,b);      :};
UnionDiffExpr ::= UnionDiffExpr:a MINUS:o NumUnopExpr:b     {: RESULT=ExprBinary.Op.MINUS.make(o,a,b);     :};

NumUnopExpr ::=          OverrideExpr:b      {: RESULT=b;                                   :};
NumUnopExpr ::= HASH:o   NumUnopExpr:b       {: RESULT=ExprUnary.Op.CARDINALITY.make(o,b);  :};
NumUnopExpr ::= SUM:o    NumUnopExpr:b       {: RESULT=ExprUnary.Op.SUM        .make(o,b);  :};
NumUnopExpr ::= INT:o    NumUnopExpr:b       {: RESULT=ExprUnary.Op.SUM        .make(o,b);  :};
NumUnopExpr ::= DOLLAR:o NumUnopExpr:b       {: RESULT=ExprUnary.Op.INTTOATOM  .make(o,b);  :};

OverrideExpr ::=                           IntersectExpr:b   {: RESULT=b;                                   :};
OverrideExpr ::= OverrideExpr:a PLUSPLUS:o IntersectExpr:b   {: RESULT=ExprBinary.Op.PLUSPLUS.make(o,a,b);  :};

IntersectExpr ::=                             RelationExpr:b {: RESULT=b;                                   :};
IntersectExpr ::= IntersectExpr:a AMPERSAND:o RelationExpr:b {: RESULT=ExprBinary.Op.INTERSECT.make(o,a,b); :};

RelationExpr ::= DomainExpr:a                                  {: RESULT=a;                                          :};
RelationExpr ::= DomainExpr:a ARROW:o           RelationExpr:b {: RESULT=ExprBinary.Op.ARROW           .make(o,a,b); :};
RelationExpr ::= DomainExpr:a ANY_ARROW_SOME:o  RelationExpr:b {: RESULT=ExprBinary.Op.ANY_ARROW_SOME  .make(o,a,b); :};
RelationExpr ::= DomainExpr:a ANY_ARROW_ONE:o   RelationExpr:b {: RESULT=ExprBinary.Op.ANY_ARROW_ONE   .make(o,a,b); :};
RelationExpr ::= DomainExpr:a ANY_ARROW_LONE:o  RelationExpr:b {: RESULT=ExprBinary.Op.ANY_ARROW_LONE  .make(o,a,b); :};
RelationExpr ::= DomainExpr:a SOME_ARROW_ANY:o  RelationExpr:b {: RESULT=ExprBinary.Op.SOME_ARROW_ANY  .make(o,a,b); :};
RelationExpr ::= DomainExpr:a SOME_ARROW_SOME:o RelationExpr:b {: RESULT=ExprBinary.Op.SOME_ARROW_SOME .make(o,a,b); :};
RelationExpr ::= DomainExpr:a SOME_ARROW_ONE:o  RelationExpr:b {: RESULT=ExprBinary.Op.SOME_ARROW_ONE  .make(o,a,b); :};
RelationExpr ::= DomainExpr:a SOME_ARROW_LONE:o RelationExpr:b {: RESULT=ExprBinary.Op.SOME_ARROW_LONE .make(o,a,b); :};
RelationExpr ::= DomainExpr:a ONE_ARROW_ANY:o   RelationExpr:b {: RESULT=ExprBinary.Op.ONE_ARROW_ANY   .make(o,a,b); :};
RelationExpr ::= DomainExpr:a ONE_ARROW_SOME:o  RelationExpr:b {: RESULT=ExprBinary.Op.ONE_ARROW_SOME  .make(o,a,b); :};
RelationExpr ::= DomainExpr:a ONE_ARROW_ONE:o   RelationExpr:b {: RESULT=ExprBinary.Op.ONE_ARROW_ONE   .make(o,a,b); :};
RelationExpr ::= DomainExpr:a ONE_ARROW_LONE:o  RelationExpr:b {: RESULT=ExprBinary.Op.ONE_ARROW_LONE  .make(o,a,b); :};
RelationExpr ::= DomainExpr:a LONE_ARROW_ANY:o  RelationExpr:b {: RESULT=ExprBinary.Op.LONE_ARROW_ANY  .make(o,a,b); :};
RelationExpr ::= DomainExpr:a LONE_ARROW_SOME:o RelationExpr:b {: RESULT=ExprBinary.Op.LONE_ARROW_SOME .make(o,a,b); :};
RelationExpr ::= DomainExpr:a LONE_ARROW_ONE:o  RelationExpr:b {: RESULT=ExprBinary.Op.LONE_ARROW_ONE  .make(o,a,b); :};
RelationExpr ::= DomainExpr:a LONE_ARROW_LONE:o RelationExpr:b {: RESULT=ExprBinary.Op.LONE_ARROW_LONE .make(o,a,b); :};

DomainExpr ::=                       RangeExpr:b          {: RESULT=b;                                   :};
DomainExpr ::= DomainExpr:a DOMAIN:o RangeExpr:b          {: RESULT=ExprBinary.Op.DOMAIN.make(o,a,b);    :};

RangeExpr ::=                     BracketExpr:b           {: RESULT=b;                                   :};
RangeExpr ::= RangeExpr:a RANGE:o BracketExpr:b           {: RESULT=ExprBinary.Op.RANGE.make(o,a,b);     :};

BracketExpr ::= DotExpr:b                               {: RESULT=b;                                                                                  :};
BracketExpr ::= BracketExpr:a LBRACKET Exprs:b RBRACKET {: Expr aa=a;                      for(Expr bb:b) aa=new ExprJoin(bb.pos, bb, aa); RESULT=aa; :};
BracketExpr ::= DISJ:a        LBRACKET Exprs:b RBRACKET {: Expr aa=new ExprName(a,"disj"); for(Expr bb:b) aa=new ExprJoin(bb.pos, bb, aa); RESULT=aa; :};

DotExpr ::=                     UnopExpr:b      {: RESULT=b;                                        :};
DotExpr ::= BracketExpr:a DOT:o UnopExpr:b      {: RESULT=new ExprJoin(o,a,b                     ); :};
DotExpr ::= BracketExpr:a DOT:o DISJ:b          {: RESULT=new ExprJoin(o,a,new ExprName(b,"disj")); :};

UnopExpr ::=          BaseExpr:b      {: RESULT=b;                                   :};
UnopExpr ::= TILDE:o  UnopExpr:b      {: RESULT=ExprUnary.Op.TRANSPOSE  .make(o,b);  :};
UnopExpr ::= STAR:o   UnopExpr:b      {: RESULT=ExprUnary.Op.RCLOSURE   .make(o,b);  :};
UnopExpr ::= CARET:o  UnopExpr:b      {: RESULT=ExprUnary.Op.CLOSURE    .make(o,b);  :};

//=============================================================================

BaseExpr ::= NUMBER:x                                 {: RESULT=x;                                           :};
BaseExpr ::= NONE:x                                   {: RESULT=ExprConstant.Op.NONE.make(x);                :};
BaseExpr ::= IDEN:x                                   {: RESULT=ExprConstant.Op.IDEN.make(x);                :};
BaseExpr ::= UNIV:x                                   {: RESULT=ExprConstant.Op.UNIV.make(x);                :};
BaseExpr ::= SIGINT:x                                 {: RESULT=ExprConstant.Op.SIGINT.make(x);              :};
BaseExpr ::= THIS:o                                   {: RESULT=new ExprName(o,"this");                      :};
BaseExpr ::= LPAREN Expr:x RPAREN                     {: RESULT=x;                                           :};
BaseExpr ::= AT:o Name:x                              {: RESULT=new ExprName(o,"@"+x.name);                  :};
BaseExpr ::= Name:x                                   {: RESULT=x;                                           :};
BaseExpr ::= ExprPara:x                               {: RESULT=x;                                           :};
BaseExpr ::= LBRACE:o Declp:a ExprParaOrBar:b RBRACE  {: RESULT=ExprQuant.Op.COMPREHENSION.make(o,a,b,null); :};
BaseExpr ::= LBRACE:o Declp:a                 RBRACE  {: RESULT=ExprQuant.Op.COMPREHENSION.make(o,a,new ExprSequence(null,new ArrayList<Expr>()),null); :};

//=============================================================================
