Compiling models/examples/algorithms/stable_mutex_ring.als...
Compilation successful!
Analyzing command: run TraceShorterThanMaxSimpleLoop for 7 but 2 examples/algorithms/stable_mutex_ring/Process, 3 examples/algorithms/stable_mutex_ring/Val expect 1

Solution #1

module alloy/lang/univ
sig univ = {FirstProc_0, Ord_0, Tick_0, Tick_1, Tick_2, Tick_3, Tick_4, Tick_5, Tick_6, Val_0, Val_1}

module examples/algorithms/stable_mutex_ring
sig Process extends univ = {FirstProc_0}
  rightNeighbor :  examples/algorithms/stable_mutex_ring/Process = 
    {FirstProc_0 -> FirstProc_0}
sig Val extends univ = {Val_0, Val_1}
  nextVal :  examples/algorithms/stable_mutex_ring/Val = 
    {Val_0 -> Val_1, 
     Val_1 -> Val_0}
sig Tick extends univ = {Tick_0, Tick_1, Tick_2, Tick_3, Tick_4, Tick_5, Tick_6}
  val :  ( examples/algorithms/stable_mutex_ring/Process) ->one ( examples/algorithms/stable_mutex_ring/Val) = 
    {Tick_0 -> FirstProc_0 -> Val_0, 
     Tick_1 -> FirstProc_0 -> Val_1, 
     Tick_2 -> FirstProc_0 -> Val_1, 
     Tick_3 -> FirstProc_0 -> Val_1, 
     Tick_4 -> FirstProc_0 -> Val_1, 
     Tick_5 -> FirstProc_0 -> Val_1, 
     Tick_6 -> FirstProc_0 -> Val_0}
  runs : set examples/algorithms/stable_mutex_ring/Process = 
    {Tick_0 -> FirstProc_0, 
     Tick_5 -> FirstProc_0}
  priv : set examples/algorithms/stable_mutex_ring/Process = 
    {Tick_0 -> FirstProc_0, 
     Tick_1 -> FirstProc_0, 
     Tick_2 -> FirstProc_0, 
     Tick_3 -> FirstProc_0, 
     Tick_4 -> FirstProc_0, 
     Tick_5 -> FirstProc_0, 
     Tick_6 -> FirstProc_0}
sig FirstProc extends Process = FirstProc_0

module util/ordering[examples/algorithms/stable_mutex_ring/Tick]
sig Ord extends univ = Ord_0
  first_ :  examples/algorithms/stable_mutex_ring/Tick = 
    {Ord_0 -> Tick_0}
  last_ :  examples/algorithms/stable_mutex_ring/Tick = 
    {Ord_0 -> Tick_6}
  next_ :  ( examples/algorithms/stable_mutex_ring/Tick) ->lone ( examples/algorithms/stable_mutex_ring/Tick) = 
    {Ord_0 -> {Tick_0 -> Tick_1, Tick_1 -> Tick_2, Tick_2 -> Tick_3, Tick_3 -> Tick_4, Tick_4 -> Tick_5, Tick_5 -> Tick_6}}
  prev_ :  ( examples/algorithms/stable_mutex_ring/Tick) ->lone ( examples/algorithms/stable_mutex_ring/Tick) = 
    {Ord_0 -> {Tick_1 -> Tick_0, Tick_2 -> Tick_1, Tick_3 -> Tick_2, Tick_4 -> Tick_3, Tick_5 -> Tick_4, Tick_6 -> Tick_5}}

module util/graph[examples/algorithms/stable_mutex_ring/Process]

module util/relation

module util/graph[examples/algorithms/stable_mutex_ring/Val]

Analyzing command: run TwoPrivileged for 5 but 3 examples/algorithms/stable_mutex_ring/Process, 4 examples/algorithms/stable_mutex_ring/Val expect 1

Solution #1

module alloy/lang/univ
sig univ = {FirstProc_0, Ord_0, Process_0, Process_1, Tick_0, Tick_1, Tick_2, Tick_3, Tick_4, Val_0, Val_1, Val_2, Val_3}

module examples/algorithms/stable_mutex_ring
sig Process extends univ = {FirstProc_0, Process_0, Process_1}
  rightNeighbor :  examples/algorithms/stable_mutex_ring/Process = 
    {FirstProc_0 -> Process_1, 
     Process_0 -> FirstProc_0, 
     Process_1 -> Process_0}
sig Val extends univ = {Val_0, Val_1, Val_2, Val_3}
  nextVal :  examples/algorithms/stable_mutex_ring/Val = 
    {Val_0 -> Val_1, 
     Val_1 -> Val_2, 
     Val_2 -> Val_3, 
     Val_3 -> Val_0}
sig Tick extends univ = {Tick_0, Tick_1, Tick_2, Tick_3, Tick_4}
  val :  ( examples/algorithms/stable_mutex_ring/Process) ->one ( examples/algorithms/stable_mutex_ring/Val) = 
    {Tick_0 -> {FirstProc_0 -> Val_0, Process_0 -> Val_2, Process_1 -> Val_0}, 
     Tick_1 -> {FirstProc_0 -> Val_0, Process_0 -> Val_0, Process_1 -> Val_2}, 
     Tick_2 -> {FirstProc_0 -> Val_0, Process_0 -> Val_0, Process_1 -> Val_2}, 
     Tick_3 -> {FirstProc_0 -> Val_0, Process_0 -> Val_0, Process_1 -> Val_0}, 
     Tick_4 -> {FirstProc_0 -> Val_1, Process_0 -> Val_0, Process_1 -> Val_0}}
  runs : set examples/algorithms/stable_mutex_ring/Process = 
    {Tick_0 -> {Process_0, Process_1}, 
     Tick_2 -> Process_1, 
     Tick_3 -> FirstProc_0}
  priv : set examples/algorithms/stable_mutex_ring/Process = 
    {Tick_0 -> {FirstProc_0, Process_0, Process_1}, 
     Tick_1 -> Process_1, 
     Tick_2 -> Process_1, 
     Tick_3 -> FirstProc_0, 
     Tick_4 -> Process_0}
sig FirstProc extends Process = FirstProc_0

module util/ordering[examples/algorithms/stable_mutex_ring/Tick]
sig Ord extends univ = Ord_0
  first_ :  examples/algorithms/stable_mutex_ring/Tick = 
    {Ord_0 -> Tick_0}
  last_ :  examples/algorithms/stable_mutex_ring/Tick = 
    {Ord_0 -> Tick_4}
  next_ :  ( examples/algorithms/stable_mutex_ring/Tick) ->lone ( examples/algorithms/stable_mutex_ring/Tick) = 
    {Ord_0 -> {Tick_0 -> Tick_1, Tick_1 -> Tick_2, Tick_2 -> Tick_3, Tick_3 -> Tick_4}}
  prev_ :  ( examples/algorithms/stable_mutex_ring/Tick) ->lone ( examples/algorithms/stable_mutex_ring/Tick) = 
    {Ord_0 -> {Tick_1 -> Tick_0, Tick_2 -> Tick_1, Tick_3 -> Tick_2, Tick_4 -> Tick_3}}

module util/graph[examples/algorithms/stable_mutex_ring/Process]

module util/relation

module util/graph[examples/algorithms/stable_mutex_ring/Val]

skolem constants
BadTick_p1 = 
    {FirstProc_0}
BadTick_p2 = 
    {Process_0}
TwoPrivileged_p1 = 
    {FirstProc_0}
TwoPrivileged_p2 = 
    {Process_0}
TwoPrivileged_t1 = 
    {Tick_3}
TwoPrivileged_t2 = 
    {Tick_4}

Analyzing command: check Closure for 5 but 5 examples/algorithms/stable_mutex_ring/Process, 6 examples/algorithms/stable_mutex_ring/Val expect 0

No solution found.

