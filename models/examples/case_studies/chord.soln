Compiling models/examples/case_studies/chord.als...
Compilation successful!
Analyzing command: check Same1 for 3 but 1 examples/case_studies/chord/State expect 0

No solution found.

Analyzing command: check Same2 for 3 but 1 examples/case_studies/chord/State expect 0

No solution found.

Analyzing command: check SameFC for 3 but 1 examples/case_studies/chord/State expect 0

No solution found.

Analyzing command: run ShowMeFC for 2 but 1 examples/case_studies/chord/State expect 1

Solution #1

module alloy/lang/univ
sig univ = {State_0}

module examples/case_studies/chord
sig Id extends univ = {}
  next :  examples/case_studies/chord/Id = 
    {}
sig Node extends univ = {}
  id :  examples/case_studies/chord/Id = 
    {}
sig NodeData extends univ = {}
  prev :  examples/case_studies/chord/Node = 
    {}
  next :  examples/case_studies/chord/Node = 
    {}
  finger :  ( examples/case_studies/chord/Id) ->lone ( examples/case_studies/chord/Node) = 
    {}
  closest_preceding_finger :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {}
  find_predecessor :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {}
  find_successor :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {}
sig State extends univ = {State_0}
  active : set examples/case_studies/chord/Node = 
    {}
  data :  ( this . active) ->one ( examples/case_studies/chord/NodeData) = 
    {}

module util/relation

Analyzing command: check SameCPF for 3 but 1 examples/case_studies/chord/State expect 0

No solution found.

Analyzing command: check SameCPF1 for 2 but 1 examples/case_studies/chord/State expect 0

No solution found.

Analyzing command: check SameCPF2 for 3 but 1 examples/case_studies/chord/State expect 0

No solution found.

Analyzing command: run ShowMeCPF for 2 but 1 examples/case_studies/chord/State expect 1

Solution #1

module alloy/lang/univ
sig univ = {Id_0, Id_1, NodeData_0, NodeData_1, Node_0, Node_1, State_0}

module examples/case_studies/chord
sig Id extends univ = {Id_0, Id_1}
  next :  examples/case_studies/chord/Id = 
    {Id_0 -> Id_1, 
     Id_1 -> Id_0}
sig Node extends univ = {Node_0, Node_1}
  id :  examples/case_studies/chord/Id = 
    {Node_0 -> Id_0, 
     Node_1 -> Id_1}
sig NodeData extends univ = {NodeData_0, NodeData_1}
  prev :  examples/case_studies/chord/Node = 
    {NodeData_0 -> Node_0, 
     NodeData_1 -> Node_1}
  next :  examples/case_studies/chord/Node = 
    {NodeData_0 -> Node_1, 
     NodeData_1 -> Node_0}
  finger :  ( examples/case_studies/chord/Id) ->lone ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> Id_1 -> Node_1, 
     NodeData_1 -> Id_0 -> Node_0}
  closest_preceding_finger :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_1, Id_1 -> Node_0}, 
     NodeData_1 -> {Id_0 -> Node_1, Id_1 -> Node_0}}
  find_predecessor :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_1, Id_1 -> Node_0}, 
     NodeData_1 -> {Id_0 -> Node_1, Id_1 -> Node_0}}
  find_successor :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_1, Id_1 -> Node_0}, 
     NodeData_1 -> {Id_0 -> Node_1, Id_1 -> Node_0}}
sig State extends univ = {State_0}
  active : set examples/case_studies/chord/Node = 
    {State_0 -> {Node_0, Node_1}}
  data :  ( this . active) ->one ( examples/case_studies/chord/NodeData) = 
    {State_0 -> {Node_0 -> NodeData_0, Node_1 -> NodeData_1}}

module util/relation

Analyzing command: check FPisActive for 3 but 1 examples/case_studies/chord/State expect 1

Solution #1

module alloy/lang/univ
sig univ = {Id_0, Id_1, Id_2, NodeData_0, NodeData_1, Node_0, Node_1, Node_2, State_0}

module examples/case_studies/chord
sig Id extends univ = {Id_0, Id_1, Id_2}
  next :  examples/case_studies/chord/Id = 
    {Id_0 -> Id_1, 
     Id_1 -> Id_2, 
     Id_2 -> Id_0}
sig Node extends univ = {Node_0, Node_1, Node_2}
  id :  examples/case_studies/chord/Id = 
    {Node_0 -> Id_2, 
     Node_1 -> Id_0, 
     Node_2 -> Id_1}
sig NodeData extends univ = {NodeData_0, NodeData_1}
  prev :  examples/case_studies/chord/Node = 
    {NodeData_0 -> Node_2, 
     NodeData_1 -> Node_2}
  next :  examples/case_studies/chord/Node = 
    {NodeData_0 -> Node_0, 
     NodeData_1 -> Node_1}
  finger :  ( examples/case_studies/chord/Id) ->lone ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_0, Id_1 -> Node_0}, 
     NodeData_1 -> {Id_0 -> Node_1, Id_1 -> Node_2, Id_2 -> Node_2}}
  closest_preceding_finger :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_0, Id_1 -> Node_0, Id_2 -> Node_0}, 
     NodeData_1 -> {Id_0 -> Node_1, Id_1 -> Node_2, Id_2 -> Node_2}}
  find_predecessor :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_2, Id_1 -> Node_2, Id_2 -> Node_0}, 
     NodeData_1 -> {Id_0 -> Node_2, Id_1 -> Node_2, Id_2 -> Node_2}}
  find_successor :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_0, Id_1 -> Node_0, Id_2 -> Node_0}, 
     NodeData_1 -> {Id_0 -> Node_0, Id_1 -> Node_0, Id_2 -> Node_0}}
sig State extends univ = {State_0}
  active : set examples/case_studies/chord/Node = 
    {State_0 -> Node_0}
  data :  ( this . active) ->one ( examples/case_studies/chord/NodeData) = 
    {State_0 -> Node_0 -> NodeData_0}

module util/relation

skolem constants
FPisActive_s = 
    {State_0}
FPisActive_n = 
    {Node_0}
FPisActive_nd = 
    {NodeData_0}

Analyzing command: check SameFP for 3 but 1 examples/case_studies/chord/State expect 1

Solution #1

module alloy/lang/univ
sig univ = {Id_0, Id_1, NodeData_0, Node_0, Node_1, State_0}

module examples/case_studies/chord
sig Id extends univ = {Id_0, Id_1}
  next :  examples/case_studies/chord/Id = 
    {Id_0 -> Id_1, 
     Id_1 -> Id_0}
sig Node extends univ = {Node_0, Node_1}
  id :  examples/case_studies/chord/Id = 
    {Node_0 -> Id_0, 
     Node_1 -> Id_1}
sig NodeData extends univ = {NodeData_0}
  prev :  examples/case_studies/chord/Node = 
    {NodeData_0 -> Node_1}
  next :  examples/case_studies/chord/Node = 
    {NodeData_0 -> Node_1}
  finger :  ( examples/case_studies/chord/Id) ->lone ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_1, Id_1 -> Node_1}}
  closest_preceding_finger :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_0, Id_1 -> Node_1}}
  find_predecessor :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_1, Id_1 -> Node_1}}
  find_successor :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_0, Id_1 -> Node_0}}
sig State extends univ = {State_0}
  active : set examples/case_studies/chord/Node = 
    {State_0 -> Node_1}
  data :  ( this . active) ->one ( examples/case_studies/chord/NodeData) = 
    {State_0 -> Node_1 -> NodeData_0}

module util/relation

skolem constants
SameFP_s = 
    {State_0}

Analyzing command: check SameFP1 for 3 but 1 examples/case_studies/chord/State expect 0

No solution found.

Analyzing command: check SameFP2 for 3 but 1 examples/case_studies/chord/State expect 0

No solution found.

Analyzing command: run ShowMe1Node for 2 but 1 examples/case_studies/chord/State, 1 examples/case_studies/chord/Node expect 1

Solution #1

module alloy/lang/univ
sig univ = {Id_0, NodeData_0, Node_0, State_0}

module examples/case_studies/chord
sig Id extends univ = {Id_0}
  next :  examples/case_studies/chord/Id = 
    {Id_0 -> Id_0}
sig Node extends univ = {Node_0}
  id :  examples/case_studies/chord/Id = 
    {Node_0 -> Id_0}
sig NodeData extends univ = {NodeData_0}
  prev :  examples/case_studies/chord/Node = 
    {NodeData_0 -> Node_0}
  next :  examples/case_studies/chord/Node = 
    {NodeData_0 -> Node_0}
  finger :  ( examples/case_studies/chord/Id) ->lone ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> Id_0 -> Node_0}
  closest_preceding_finger :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> Id_0 -> Node_0}
  find_predecessor :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> Id_0 -> Node_0}
  find_successor :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> Id_0 -> Node_0}
sig State extends univ = {State_0}
  active : set examples/case_studies/chord/Node = 
    {State_0 -> Node_0}
  data :  ( this . active) ->one ( examples/case_studies/chord/NodeData) = 
    {State_0 -> Node_0 -> NodeData_0}

module util/relation

Analyzing command: run ShowMe1 for 3 expect 1

Solution #1

module alloy/lang/univ
sig univ = {Id_0, Id_1, Id_2, NodeData_0, NodeData_1, Node_0, Node_1, State_0}

module examples/case_studies/chord
sig Id extends univ = {Id_0, Id_1, Id_2}
  next :  examples/case_studies/chord/Id = 
    {Id_0 -> Id_1, 
     Id_1 -> Id_2, 
     Id_2 -> Id_0}
sig Node extends univ = {Node_0, Node_1}
  id :  examples/case_studies/chord/Id = 
    {Node_0 -> Id_0, 
     Node_1 -> Id_1}
sig NodeData extends univ = {NodeData_0, NodeData_1}
  prev :  examples/case_studies/chord/Node = 
    {NodeData_0 -> Node_0, 
     NodeData_1 -> Node_0}
  next :  examples/case_studies/chord/Node = 
    {NodeData_0 -> Node_0, 
     NodeData_1 -> Node_1}
  finger :  ( examples/case_studies/chord/Id) ->lone ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_1, Id_1 -> Node_0, Id_2 -> Node_0}, 
     NodeData_1 -> {Id_0 -> Node_1, Id_1 -> Node_1, Id_2 -> Node_1}}
  closest_preceding_finger :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_0, Id_1 -> Node_0, Id_2 -> Node_0}, 
     NodeData_1 -> {Id_0 -> Node_0, Id_1 -> Node_0, Id_2 -> Node_0}}
  find_predecessor :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_0, Id_1 -> Node_0, Id_2 -> Node_0}, 
     NodeData_1 -> {Id_0 -> Node_0, Id_1 -> Node_0, Id_2 -> Node_0}}
  find_successor :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_0, Id_1 -> Node_0, Id_2 -> Node_0}, 
     NodeData_1 -> {Id_0 -> Node_0, Id_1 -> Node_0, Id_2 -> Node_0}}
sig State extends univ = {State_0}
  active : set examples/case_studies/chord/Node = 
    {State_0 -> {Node_0, Node_1}}
  data :  ( this . active) ->one ( examples/case_studies/chord/NodeData) = 
    {State_0 -> {Node_0 -> NodeData_1, Node_1 -> NodeData_0}}

module util/relation

Analyzing command: run ShowMe2 for 3 expect 1

Solution #1

module alloy/lang/univ
sig univ = {Id_0, Id_1, Id_2, NodeData_0, NodeData_1, NodeData_2, Node_0, Node_1, Node_2, State_0}

module examples/case_studies/chord
sig Id extends univ = {Id_0, Id_1, Id_2}
  next :  examples/case_studies/chord/Id = 
    {Id_0 -> Id_1, 
     Id_1 -> Id_2, 
     Id_2 -> Id_0}
sig Node extends univ = {Node_0, Node_1, Node_2}
  id :  examples/case_studies/chord/Id = 
    {Node_0 -> Id_0, 
     Node_1 -> Id_1, 
     Node_2 -> Id_2}
sig NodeData extends univ = {NodeData_0, NodeData_1, NodeData_2}
  prev :  examples/case_studies/chord/Node = 
    {NodeData_0 -> Node_0, 
     NodeData_1 -> Node_1, 
     NodeData_2 -> Node_2}
  next :  examples/case_studies/chord/Node = 
    {NodeData_0 -> Node_2, 
     NodeData_1 -> Node_1, 
     NodeData_2 -> Node_0}
  finger :  ( examples/case_studies/chord/Id) ->lone ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_0, Id_1 -> Node_1, Id_2 -> Node_2}, 
     NodeData_1 -> {Id_0 -> Node_0, Id_1 -> Node_1}, 
     NodeData_2 -> {Id_0 -> Node_0, Id_1 -> Node_1}}
  closest_preceding_finger :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_0, Id_1 -> Node_2, Id_2 -> Node_0}, 
     NodeData_1 -> {Id_0 -> Node_0, Id_1 -> Node_2, Id_2 -> Node_0}, 
     NodeData_2 -> {Id_0 -> Node_0, Id_1 -> Node_2, Id_2 -> Node_0}}
  find_predecessor :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_2, Id_1 -> Node_2, Id_2 -> Node_2}, 
     NodeData_1 -> {Id_0 -> Node_2, Id_1 -> Node_2, Id_2 -> Node_2}, 
     NodeData_2 -> {Id_0 -> Node_2, Id_1 -> Node_2, Id_2 -> Node_2}}
  find_successor :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_2, Id_1 -> Node_2, Id_2 -> Node_2}, 
     NodeData_1 -> {Id_0 -> Node_2, Id_1 -> Node_2, Id_2 -> Node_2}, 
     NodeData_2 -> {Id_0 -> Node_2, Id_1 -> Node_2, Id_2 -> Node_2}}
sig State extends univ = {State_0}
  active : set examples/case_studies/chord/Node = 
    {State_0 -> {Node_0, Node_1, Node_2}}
  data :  ( this . active) ->one ( examples/case_studies/chord/NodeData) = 
    {State_0 -> {Node_0 -> NodeData_1, Node_1 -> NodeData_0, Node_2 -> NodeData_2}}

module util/relation

Analyzing command: check InjectiveIds for 5 expect 0

No solution found.

Analyzing command: check FindSuccessorWorks for 3 but 1 examples/case_studies/chord/State expect 1

Solution #1

module alloy/lang/univ
sig univ = {Id_0, Id_1, Id_2, NodeData_0, NodeData_1, NodeData_2, Node_0, Node_1, Node_2, State_0}

module examples/case_studies/chord
sig Id extends univ = {Id_0, Id_1, Id_2}
  next :  examples/case_studies/chord/Id = 
    {Id_0 -> Id_1, 
     Id_1 -> Id_2, 
     Id_2 -> Id_0}
sig Node extends univ = {Node_0, Node_1, Node_2}
  id :  examples/case_studies/chord/Id = 
    {Node_0 -> Id_1, 
     Node_1 -> Id_0, 
     Node_2 -> Id_2}
sig NodeData extends univ = {NodeData_0, NodeData_1, NodeData_2}
  prev :  examples/case_studies/chord/Node = 
    {NodeData_0 -> Node_0, 
     NodeData_1 -> Node_0, 
     NodeData_2 -> Node_2}
  next :  examples/case_studies/chord/Node = 
    {NodeData_0 -> Node_0, 
     NodeData_1 -> Node_2, 
     NodeData_2 -> Node_0}
  finger :  ( examples/case_studies/chord/Id) ->lone ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_0, Id_1 -> Node_1, Id_2 -> Node_1}, 
     NodeData_1 -> {Id_0 -> Node_0, Id_1 -> Node_1, Id_2 -> Node_1}, 
     NodeData_2 -> {Id_0 -> Node_0, Id_1 -> Node_0, Id_2 -> Node_0}}
  closest_preceding_finger :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_0, Id_1 -> Node_1, Id_2 -> Node_1}, 
     NodeData_1 -> {Id_0 -> Node_0, Id_1 -> Node_1, Id_2 -> Node_1}, 
     NodeData_2 -> {Id_0 -> Node_0, Id_1 -> Node_1, Id_2 -> Node_1}}
  find_predecessor :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_2, Id_1 -> Node_2, Id_2 -> Node_2}, 
     NodeData_1 -> {Id_0 -> Node_2, Id_1 -> Node_2, Id_2 -> Node_2}, 
     NodeData_2 -> {Id_0 -> Node_2, Id_1 -> Node_2, Id_2 -> Node_2}}
  find_successor :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_2, Id_1 -> Node_2, Id_2 -> Node_2}, 
     NodeData_1 -> {Id_0 -> Node_2, Id_1 -> Node_2, Id_2 -> Node_2}, 
     NodeData_2 -> {Id_0 -> Node_2, Id_1 -> Node_2, Id_2 -> Node_2}}
sig State extends univ = {State_0}
  active : set examples/case_studies/chord/Node = 
    {State_0 -> Node_0}
  data :  ( this . active) ->one ( examples/case_studies/chord/NodeData) = 
    {State_0 -> Node_0 -> NodeData_2}

module util/relation

skolem constants
FindSuccessorWorks_s = 
    {State_0}
FindSuccessorWorks_i = 
    {Id_0}
FindSuccessorWorks_n' = 
    {Node_0}

