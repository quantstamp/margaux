Compiling models/examples/case_studies/chordbugmodel.als...
Compilation successful!
Analyzing command: run ShowMe1Node for 2 but 1 examples/case_studies/chord/State, 1 examples/case_studies/chord/Node expect 1

Solution #1

module alloy/lang/univ
sig univ = {Id_0, NodeData_0, Node_0, State_0}

module examples/case_studies/chord
sig Id extends univ = {Id_0}
  next :  examples/case_studies/chord/Id = 
    {Id_0 -> Id_0}
sig Node extends univ = {Node_0}
  id :  examples/case_studies/chord/Id = 
    {Node_0 -> Id_0}
sig NodeData extends univ = {NodeData_0}
  next :  examples/case_studies/chord/Node = 
    {NodeData_0 -> Node_0}
  finger :  ( examples/case_studies/chord/Id) ->lone ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> Id_0 -> Node_0}
  closest_preceding_finger :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> Id_0 -> Node_0}
  find_successor :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> Id_0 -> Node_0}
sig State extends univ = {State_0}
  active : set examples/case_studies/chord/Node = 
    {State_0 -> Node_0}
  data :  ( this . active) ->one ( examples/case_studies/chord/NodeData) = 
    {State_0 -> Node_0 -> NodeData_0}

Analyzing command: run ShowMeGood for 4 but 1 examples/case_studies/chord/State, 2 examples/case_studies/chord/Node expect 1

Solution #1

module alloy/lang/univ
sig univ = {Id_0, Id_1, Id_2, Id_3, State_0}

module examples/case_studies/chord
sig Id extends univ = {Id_0, Id_1, Id_2, Id_3}
  next :  examples/case_studies/chord/Id = 
    {Id_0 -> Id_1, 
     Id_1 -> Id_2, 
     Id_2 -> Id_3, 
     Id_3 -> Id_0}
sig Node extends univ = {}
  id :  examples/case_studies/chord/Id = 
    {}
sig NodeData extends univ = {}
  next :  examples/case_studies/chord/Node = 
    {}
  finger :  ( examples/case_studies/chord/Id) ->lone ( examples/case_studies/chord/Node) = 
    {}
  closest_preceding_finger :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {}
  find_successor :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {}
sig State extends univ = {State_0}
  active : set examples/case_studies/chord/Node = 
    {}
  data :  ( this . active) ->one ( examples/case_studies/chord/NodeData) = 
    {}

Analyzing command: run ShowMeCorrectSuccessorEg for 3 but 1 examples/case_studies/chord/State expect 1

Solution #1

module alloy/lang/univ
sig univ = {Id_0, Id_1, Id_2, NodeData_0, NodeData_1, NodeData_2, Node_0, Node_1, Node_2, State_0}

module examples/case_studies/chord
sig Id extends univ = {Id_0, Id_1, Id_2}
  next :  examples/case_studies/chord/Id = 
    {Id_0 -> Id_1, 
     Id_1 -> Id_2, 
     Id_2 -> Id_0}
sig Node extends univ = {Node_0, Node_1, Node_2}
  id :  examples/case_studies/chord/Id = 
    {Node_0 -> Id_0, 
     Node_1 -> Id_1, 
     Node_2 -> Id_2}
sig NodeData extends univ = {NodeData_0, NodeData_1, NodeData_2}
  next :  examples/case_studies/chord/Node = 
    {NodeData_0 -> Node_0, 
     NodeData_1 -> Node_1, 
     NodeData_2 -> Node_2}
  finger :  ( examples/case_studies/chord/Id) ->lone ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> Id_0 -> Node_0, 
     NodeData_1 -> {Id_0 -> Node_0, Id_1 -> Node_1}, 
     NodeData_2 -> {Id_0 -> Node_0, Id_2 -> Node_2}}
  closest_preceding_finger :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_0, Id_1 -> Node_2, Id_2 -> Node_0}, 
     NodeData_1 -> {Id_0 -> Node_0, Id_1 -> Node_2, Id_2 -> Node_0}, 
     NodeData_2 -> {Id_0 -> Node_0, Id_1 -> Node_2, Id_2 -> Node_0}}
  find_successor :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_0, Id_1 -> Node_1, Id_2 -> Node_2}, 
     NodeData_1 -> {Id_0 -> Node_0, Id_1 -> Node_1, Id_2 -> Node_2}, 
     NodeData_2 -> {Id_0 -> Node_0, Id_1 -> Node_1, Id_2 -> Node_2}}
sig State extends univ = {State_0}
  active : set examples/case_studies/chord/Node = 
    {State_0 -> {Node_0, Node_1, Node_2}}
  data :  ( this . active) ->one ( examples/case_studies/chord/NodeData) = 
    {State_0 -> {Node_0 -> NodeData_1, Node_1 -> NodeData_2, Node_2 -> NodeData_0}}

Analyzing command: run ShowMe3 for 5 but 1 examples/case_studies/chord/State expect 1

Solution #1

module alloy/lang/univ
sig univ = {Id_0, Id_1, Id_2, Id_3, Id_4, NodeData_0, NodeData_1, NodeData_2, NodeData_3, NodeData_4, Node_0, Node_1, Node_2, State_0}

module examples/case_studies/chord
sig Id extends univ = {Id_0, Id_1, Id_2, Id_3, Id_4}
  next :  examples/case_studies/chord/Id = 
    {Id_0 -> Id_1, 
     Id_1 -> Id_2, 
     Id_2 -> Id_3, 
     Id_3 -> Id_4, 
     Id_4 -> Id_0}
sig Node extends univ = {Node_0, Node_1, Node_2}
  id :  examples/case_studies/chord/Id = 
    {Node_0 -> Id_2, 
     Node_1 -> Id_3, 
     Node_2 -> Id_4}
sig NodeData extends univ = {NodeData_0, NodeData_1, NodeData_2, NodeData_3, NodeData_4}
  next :  examples/case_studies/chord/Node = 
    {NodeData_0 -> Node_0, 
     NodeData_1 -> Node_1, 
     NodeData_2 -> Node_1, 
     NodeData_3 -> Node_2, 
     NodeData_4 -> Node_2}
  finger :  ( examples/case_studies/chord/Id) ->lone ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_0, Id_1 -> Node_2, Id_2 -> Node_2, Id_3 -> Node_2, Id_4 -> Node_2}, 
     NodeData_1 -> {Id_0 -> Node_0, Id_1 -> Node_2, Id_2 -> Node_2, Id_3 -> Node_1, Id_4 -> Node_2}, 
     NodeData_2 -> {Id_0 -> Node_1, Id_1 -> Node_2, Id_2 -> Node_2, Id_3 -> Node_2, Id_4 -> Node_2}, 
     NodeData_3 -> {Id_0 -> Node_2, Id_1 -> Node_2, Id_2 -> Node_2, Id_3 -> Node_2, Id_4 -> Node_2}, 
     NodeData_4 -> {Id_1 -> Node_2, Id_2 -> Node_2, Id_3 -> Node_2, Id_4 -> Node_2}}
  closest_preceding_finger :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_2, Id_1 -> Node_2, Id_2 -> Node_2, Id_3 -> Node_2, Id_4 -> Node_2}, 
     NodeData_1 -> {Id_0 -> Node_2, Id_1 -> Node_2, Id_2 -> Node_2, Id_3 -> Node_2, Id_4 -> Node_2}, 
     NodeData_2 -> {Id_0 -> Node_2, Id_1 -> Node_2, Id_2 -> Node_2, Id_3 -> Node_2, Id_4 -> Node_2}, 
     NodeData_3 -> {Id_0 -> Node_2, Id_1 -> Node_2, Id_2 -> Node_2, Id_3 -> Node_2, Id_4 -> Node_2}, 
     NodeData_4 -> {Id_0 -> Node_2, Id_1 -> Node_2, Id_2 -> Node_2, Id_3 -> Node_2, Id_4 -> Node_2}}
  find_successor :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_2, Id_1 -> Node_2, Id_2 -> Node_2, Id_3 -> Node_2, Id_4 -> Node_2}, 
     NodeData_1 -> {Id_0 -> Node_2, Id_1 -> Node_2, Id_2 -> Node_2, Id_3 -> Node_2, Id_4 -> Node_2}, 
     NodeData_2 -> {Id_0 -> Node_2, Id_1 -> Node_2, Id_2 -> Node_2, Id_3 -> Node_2, Id_4 -> Node_2}, 
     NodeData_3 -> {Id_0 -> Node_2, Id_1 -> Node_2, Id_2 -> Node_2, Id_3 -> Node_2, Id_4 -> Node_2}, 
     NodeData_4 -> {Id_0 -> Node_2, Id_1 -> Node_2, Id_2 -> Node_2, Id_3 -> Node_2, Id_4 -> Node_2}}
sig State extends univ = {State_0}
  active : set examples/case_studies/chord/Node = 
    {State_0 -> {Node_0, Node_1, Node_2}}
  data :  ( this . active) ->one ( examples/case_studies/chord/NodeData) = 
    {State_0 -> {Node_0 -> NodeData_1, Node_1 -> NodeData_3, Node_2 -> NodeData_0}}

Analyzing command: run FindSuccessorWorks for 4 but 1 examples/case_studies/chord/State expect 0

No solution found.

Analyzing command: check StrongerFindSuccessorWorks for 4 but 1 examples/case_studies/chord/State expect 1

Solution #1

module alloy/lang/univ
sig univ = {Id_0, Id_1, Id_2, Id_3, NodeData_0, NodeData_1, NodeData_2, NodeData_3, Node_0, Node_1, Node_2, State_0}

module examples/case_studies/chord
sig Id extends univ = {Id_0, Id_1, Id_2, Id_3}
  next :  examples/case_studies/chord/Id = 
    {Id_0 -> Id_1, 
     Id_1 -> Id_2, 
     Id_2 -> Id_3, 
     Id_3 -> Id_0}
sig Node extends univ = {Node_0, Node_1, Node_2}
  id :  examples/case_studies/chord/Id = 
    {Node_0 -> Id_2, 
     Node_1 -> Id_1, 
     Node_2 -> Id_3}
sig NodeData extends univ = {NodeData_0, NodeData_1, NodeData_2, NodeData_3}
  next :  examples/case_studies/chord/Node = 
    {NodeData_0 -> Node_0, 
     NodeData_1 -> Node_0, 
     NodeData_2 -> Node_0, 
     NodeData_3 -> Node_0}
  finger :  ( examples/case_studies/chord/Id) ->lone ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_0, Id_1 -> Node_0, Id_2 -> Node_2, Id_3 -> Node_1}, 
     NodeData_1 -> {Id_0 -> Node_0, Id_1 -> Node_1, Id_2 -> Node_2, Id_3 -> Node_0}, 
     NodeData_2 -> {Id_0 -> Node_0, Id_1 -> Node_2, Id_2 -> Node_2, Id_3 -> Node_2}, 
     NodeData_3 -> {Id_0 -> Node_0, Id_2 -> Node_2, Id_3 -> Node_2}}
  closest_preceding_finger :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_1, Id_1 -> Node_1, Id_2 -> Node_2, Id_3 -> Node_2}, 
     NodeData_1 -> {Id_0 -> Node_1, Id_1 -> Node_1, Id_2 -> Node_2, Id_3 -> Node_2}, 
     NodeData_2 -> {Id_0 -> Node_1, Id_1 -> Node_1, Id_2 -> Node_2, Id_3 -> Node_2}, 
     NodeData_3 -> {Id_0 -> Node_2, Id_1 -> Node_1, Id_2 -> Node_2, Id_3 -> Node_2}}
  find_successor :  ( examples/case_studies/chord/Id) ->one ( examples/case_studies/chord/Node) = 
    {NodeData_0 -> {Id_0 -> Node_2, Id_1 -> Node_1, Id_2 -> Node_2, Id_3 -> Node_2}, 
     NodeData_1 -> {Id_0 -> Node_2, Id_1 -> Node_1, Id_2 -> Node_2, Id_3 -> Node_2}, 
     NodeData_2 -> {Id_0 -> Node_2, Id_1 -> Node_1, Id_2 -> Node_2, Id_3 -> Node_2}, 
     NodeData_3 -> {Id_0 -> Node_2, Id_1 -> Node_1, Id_2 -> Node_2, Id_3 -> Node_2}}
sig State extends univ = {State_0}
  active : set examples/case_studies/chord/Node = 
    {State_0 -> Node_0}
  data :  ( this . active) ->one ( examples/case_studies/chord/NodeData) = 
    {State_0 -> Node_0 -> NodeData_1}

skolem constants
StrongerFindSuccessorWorks_s = 
    {State_0}
FindSuccessorIsCorrect_i = 
    {Id_0}
FindSuccessorIsCorrect_n = 
    {Node_0}
FindSuccessorIsCorrect_n' = 
    {}

