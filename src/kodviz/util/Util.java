/* * Alloy Analyzer * Copyright (c) 2002 Massachusetts Institute of Technology * * The Alloy Analyzer is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation; either version 2 of the License, or * (at your option) any later version. * * The Alloy Analyzer is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with the Alloy Analyzer; if not, write to the Free Software * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */package kodviz.util;import java.io.ByteArrayOutputStream;import java.io.PrintWriter;import java.io.StringWriter;import java.io.Writer;import java.math.BigInteger;import java.util.ArrayList;import java.util.BitSet;import java.util.Collection;import java.util.Collections;import java.util.HashMap;import java.util.HashSet;import java.util.Iterator;import java.util.LinkedHashMap;import java.util.LinkedHashSet;import java.util.List;import java.util.Map;import java.util.Set;import java.util.TreeMap;import java.util.TreeSet;/** * Miscellaneous utility functions. */@SuppressWarnings("unchecked")public class Util {    /** The empty map.  ({@link Collections#EMPTY_MAP} was only added in 1.3). */    public static final Map EMPTY_MAP = Collections.unmodifiableMap(new HashMap());    /** The empty {@link BitSet}. */    public static final BitSet EMPTY_BITSET = new BitSet();        /** Factorial */    public static long fact(long n_) {	long result = 1;	for (long i=1; i<=n_; i++)	    result *= i;	return result;    }    /** Factorial */    public static BigInteger fact(BigInteger n_) {	BigInteger result = BigInteger.ONE;	for (BigInteger i = BigInteger.ONE; i.compareTo(n_) <= 0;	     i = i.add(BigInteger.ONE))	    result = result.multiply(i);	return result;    }    /**     * Factorial on doubles; avoids overflow problems present     * when using integers.     * @param n_ arg on which to compute factorial     * @return (<code>double</code> approximation to) factorial of largest positive     *         integer <= (n_ + epsilon)     */    public static double fact(double n_) {	n_ += 1e-6;	double result = 1.0;	for (double i=1; i<=n_; i+=1.0)	    result *= i;	return result;    }    /** Factorial */    public static int fact(int n_) {	int result = 1;	for (int i=1; i<=n_; i++)	    result *= i;	return result;    }    /**     * Create a Set with predictable iteration order.  When Java 1.4 is adopted everywhere this will return     * {@link LinkedHashSet}, but if Java 1.3 is needed this will return a {@link TreeSet} (which requires     * its elements to implement Comparable).     * @see ObjID     */    public static Set makeSet() { return new LinkedHashSet(); }    /**     * Create a Map with predictable iteration order.  When Java 1.4 is adopted everywhere this will return     * {@link LinkedHashMap}, but if Java 1.3 is needed this will return a {@link TreeMap} (which requires     * its keys to implement Comparable).     * @see ObjID     */    public static Map makeMap() { return new LinkedHashMap(); }    /** Binary log: finds the smallest power k such that 2^k>=n */    public static int binaryLogUp(int n_) {	int k=0;	while ((1 << k) < n_)	    k++;	return k;    }    /** Binary log: finds the smallest power k such that 2^k>=n */    public static int binaryLogUp(long n_) {	int k=0;	while ((1 << k) < n_)	    k++;	return k;    }    /** Convert an int[] to a {@link String} for printing */    public static String str(int[] ints_) {	StringBuffer s = new StringBuffer();	s.append("[");	for (int i=0; i<ints_.length; i++) {	    if (i>0) s.append(", ");	    s.append(ints_[i]);	}	s.append("]");	return s.toString();    }    /** Convert a long[] to a {@link String} for printing */    public static String str(long[] ints_) {	StringBuffer s = new StringBuffer();	s.append("[");	for (int i=0; i<ints_.length; i++) {	    if (i>0) s.append(", ");	    s.append(ints_[i]);	}	s.append("]");	return s.toString();    }    /**     * Get a string representation of the current stack trace.     */    public static String getStackTrace() {	NullPointerException e = new NullPointerException();	return str(e);    }    /** Get the stack trace from a given Throwable as a string. */    public static String getStackTrace( Throwable aThrowable ) {	final Writer result = new StringWriter();	final PrintWriter printWriter = new PrintWriter( result );	aThrowable.printStackTrace( printWriter );	return result.toString();    }    /** Get a {@link String} representation of a {@link Throwable}. */    public static String str(Throwable thrown_) {	// create a memory buffer to which to dump the trace	ByteArrayOutputStream traceDump = new ByteArrayOutputStream();	PrintWriter w = new PrintWriter(traceDump);	thrown_.printStackTrace(w);	w.close();	return traceDump.toString();    }    /** Convert an boolean[] to a {@link String} for printing */    public static String str(boolean[] bools_) {	StringBuffer s = new StringBuffer();	s.append("[");	for (int i=0; i<bools_.length; i++) {	    s.append(bools_[i] ? "1" : "0");	}	s.append("]");	return s.toString();    }    /**     * Parse a string containing an integer.  If the string does     * not contain a valid integer, return the specified default value.     */    public static int parseWithDefault(String val_, int default_) {	try { return Integer.parseInt(val_); }	catch (NumberFormatException nfe_) { return default_; }    }        /**     * Test whether <em>some</em> element of the given {@link Collection}     * satisfies the given {@link Predicate}.     */    public static boolean forSome(Collection c_, Predicate p_) {	for (Iterator iter = c_.iterator(); iter.hasNext();)	    if (p_.test(iter.next()))		return true;	return false;    }    /**     * Test whether <em>all</em> elements of the given {@link Collection}     * satisfy the given {@link Predicate}.     */    public static boolean forAll(Collection c_, Predicate p_) {	for (Iterator iter = c_.iterator(); iter.hasNext();)	    if (!p_.test(iter.next()))		return false;	return true;    }    /**     * Map a list: generate a new list with each element mapped.     * The new list is always an {@link ArrayList}; it would have been     * more precise to use {@link java.lang.reflect reflection} to create     * a list of the same type as 'srcList', but reflection works really     * slowly in some implementations, so it's best to avoid it.     */    public static List map(List srcList, Mapper mapper_) {	ArrayList result = new ArrayList();	for (Iterator srcIter = srcList.iterator(); srcIter.hasNext();)	    result.add(mapper_.map(srcIter.next()));	return result;    }    /**     * Map a set: generate a new set with each element mapped.     * The new set is always a {@link HashSet}; it would have been     * more precise to use {@link java.lang.reflect reflection} to create     * a set of the same type as 'srcSet', but reflection works really     * slowly in some implementations, so it's best to avoid it.     */    public static Set map(Set srcSet, Mapper mapper_) {	HashSet result = new HashSet();	for (Iterator srcIter = srcSet.iterator(); srcIter.hasNext();)	    result.add(mapper_.map(srcIter.next()));	return result;    }    /*     * Resize an int[] to have the exact given size, with the     * initial segment equal to the given int[].  If the requested     * size is the same as the current size then the array itself is     * returned, otherwise a new array is allocated, with the initial     * segment equal to the given array.     */    public static int[] realloc(int[] data_, int newSize_) {	if (data_.length != newSize_) {	    int[] newData = new int[newSize_];	    System.arraycopy(data_, 0, newData, 0, Math.min(data_.length, newSize_));	    return newData;	} else return data_;    }    /** Clear a {@link BitSet}. */    public static void clear(BitSet bitSet_) {	bitSet_.and(EMPTY_BITSET);    }    /**     * Test whether the given bit of an integer is set.  The bit numbering starts at 0 and     * increases from least significant to most significant bit.     */    public static boolean testBit(int n_, int bitNum_) {	int mask = 1 << bitNum_;	Dbg.chk(mask > 0);	return (n_ & mask) > 0;    }    /** Replace all occurrences of a given substring in a given {@link String}. */    public static String replaceAll(String str_, String sub_, String newSub_) {	if (str_.indexOf(sub_) == -1) return str_;	int subLen = sub_.length();	int idx;	StringBuffer result = new StringBuffer(str_);	while ((idx=result.toString().indexOf(sub_)) >= 0)	    result.replace(idx, idx+subLen, newSub_);	return result.toString();    }    /** Remove all occurrences of a given substring in a given {@link String} */    public static String removeAll(String str_, String sub_) {	return replaceAll(str_, sub_, "");    }    /** Test whether the two given sets intersect */    public static boolean setsIntersect(Set set1_, Set set2_) {	boolean set1smaller = set1_.size() < set2_.size();	Set smallerSet = set1smaller ? set1_ : set2_;	Set largerSet = set1smaller ? set2_ : set1_;	for (Iterator iter = smallerSet.iterator(); iter.hasNext();)	    if (largerSet.contains(iter.next()))		return true;	return false;    }}  // class Util